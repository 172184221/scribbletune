{"version":3,"sources":["webpack://scribble/webpack/universalModuleDefinition","webpack://scribble/webpack/bootstrap","webpack://scribble/./src/chord.ts","webpack://scribble/./src/utils.ts","webpack://scribble/./src/scale.ts","webpack://scribble/./src/clip.ts","webpack://scribble/./node_modules/tonal-note/build/es6.js","webpack://scribble/./node_modules/tonal-array/build/es6.js","webpack://scribble/./node_modules/tonal-interval/build/es6.js","webpack://scribble/./node_modules/tonal-distance/build/es6.js","webpack://scribble/./node_modules/tonal-pcset/build/es6.js","webpack://scribble/./node_modules/tonal-dictionary/build/es6.js","webpack://scribble/./node_modules/tonal-scale/build/es6.js","webpack://scribble/./node_modules/tonal-chord/build/es6.js","webpack://scribble/./node_modules/tonal/index.js","webpack://scribble/./src/index.ts","webpack://scribble/./src/browserClip.ts","webpack://scribble/./src/progression.ts","webpack://scribble/./src/arp.ts","webpack://scribble/./src/midi.ts","webpack://scribble/./node_modules/jsmidgen/lib/jsmidgen.js","webpack://scribble/(webpack)/buildin/module.js","webpack://scribble/./src/session.ts","webpack://scribble/./src/channel.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","tonal_1","chordNames","Chord","names","utils_1","numericalChords","4th","5th","7th","9th","11th","13th","getChord","isNote","Error","spl","split","tokenizedName","tokenize","chordName","replace","exists","TypeError","chord","map","el","note","transpose","Note","simplify","chords","test","str","expandStr","JSON","stringify","parse","shuffle","arr","lastIndex","length","forEach","idx","rnd","Math","round","random","sizzleMap","maxLevel","pi","PI","piArr","piArrRev","reverse","concat","element","sin","__importStar","this","mod","result","k","Tonal","getScale","tonicOctScale","toLowerCase","scaleName","Scale","notes","scales","chord_1","browserClip","hdr","1n","2n","4n","8n","16n","clip","params","pattern","sizzle","arpegiate","subdiv","Array","isArray","synth","instrument","sample","player","samples","sampler","clipNotes","step","recursivelyApplyPatternToNotes","push","level","NAMES","accTypes","slice","filter","acc","indexOf","SHARPS","FLATS","REGEX","exec","toUpperCase","NO_NOTE","freeze","pc","alt","oct","octStr","chroma","midi","freq","SEMI","props","fn","cache","memo","tokens","letter","charCodeAt","midiToFreq","es6_name","tuning","pow","L2","log","L440","freqToMidi","v","es6_chroma","stepToLetter","fillStr","join","altToAcc","num","op","numToStr","es6_from","fromProps","baseNote","_a","assign","build","fromMidi","sharps","floor","sameAcc","useSharps","enharmonic","range","a","b","ascR","descR","rotate","times","len","compact","height","sort","src","unique","permutations","reduce","perm","e","pos","newPerm","splice","es6_REGEX","RegExp","SIZES","CLASSES","es6_NAMES","es6_names","types","es6_tokenize","NO_IVL","q","dir","type","simple","semitones","es6_fillStr","abs","qToAlt","altToQ","numToStep","es6_properties","ic","es6_props","build_es6_name","build_es6_chroma","ivl","es6_build","_b","_c","undefined","es6_simplify","intervalProps","invert","IN","IQ","fromSemitones","FIFTHS","FIFTH_OCTS","f","STEPS","decode","unaltered","encoder","es6_memo","ref","encode","encodeNote","encodeIvl","interval","arguments","tr","trFifths","fifths","es6_fifths","from","to","transposeBy","decodeIvl","addIntervals","ivl1","ivl2","i1","i2","es6_add","subtract","es6_interval","es6_semitones","es6_chr","pcsetNum","set","parseInt","tonal_pcset_build_es6_chroma","clen","isChroma","es6_all","chromas","toString","modes","normalize","binary","_","build_es6_REGEX","IVLS","es6_intervals","isEqual","s1","s2","isSubsetOf","isSupersetOf","includes","dictionary","raw","keys","data","index","add","ivls","alias","chr","allKeys","dict","combine","es6_scale","es6_pcset","NO_SCALE","intervals","setnum","build_es6_props","memoize","build_es6_names","build_es6_intervals","build_es6_tokenize","es6_notes","nameOrTonic","tonic","substring","modeNames","tonics","x","es6_chords","inScale","toScale","pcset","scale","supersets","isSuperset","subsets","isSubset","tonal_chord_build_es6_names","NO_CHORD","tonal_chord_build_es6_props","build_es6_memo","tonal_chord_build_es6_intervals","tonal_chord_build_es6_tokenize","build_es6_notes","es6_exists","es6_supersets","es6_subsets","NUM_TYPES","__webpack_exports__","tonal_transpose","tonal_interval","tonal_note","tonal_midi","tonal_freq","tonal_chord","tonal_scale","build_es6_namespaceObject","es6_namespaceObject","tonal_interval_build_es6_namespaceObject","tonal_distance_build_es6_namespaceObject","tonal_scale_build_es6_namespaceObject","tonal_chord_build_es6_namespaceObject","tonal_pcset_build_es6_namespaceObject","tonal_dictionary_build_es6_namespaceObject","scale_1","clip_1","progression_1","progression","arp_1","arp","midi_1","session_1","session","Session","effects","eff","Tone","PanVol","pan","volume","Player","Sampler","chain","Master","Sequence","time","start","getPlayerSeqFn","counter","triggerAttackRelease","dur","getSamplerSeqFn","voices","getInstrSeqFn","getMonoInstrSeqFn","theRomans","ionian","dorian","phrygian","lydian","mixolydian","aeolian","locrian","melodic minor","harmonic minor","major","minor","idxByDegree","ii","iii","iv","vi","vii","getChords","noteOctaveScale","chordDegress","noteOctaveScaleArr","match","roman","prefix","getChordName","scaleId","fillArr","bumpOctave","arr1","arr2","chordsOrParams","finalArr","count","order","chordsArr","filledArr","reorderedArr","__importDefault","default","fs_1","jsmidgen","fileName","bytes","file","File","track","Track","addTrack","noteObj","noteOn","noteOff","addChord","createFileFromNotes","toBytes","endsWith","writeFileSync","console","Midi","exported","DEFAULT_VOLUME","Util","DEFAULT_DURATION","DEFAULT_CHANNEL","midi_letter_pitches","g","midiPitchFromNote","matches","accidental","substr","ensureMidiPitch","midi_pitches_letter","12","13","14","15","16","17","18","19","20","21","22","23","midi_flattened_notes","a#","c#","d#","f#","g#","noteFromMidiPitch","returnFlattened","noteName","octave","noteNum","mpqnFromBpm","bpm","mpqn","ret","unshift","bpmFromMpqn","codes2Str","byteArray","String","fromCharCode","apply","str2Bytes","finalBytes","chars","translateTickTime","ticks","buffer","bList","MidiEvent","channel","param1","setTime","setType","setChannel","setParam1","setParam2","param2","NOTE_OFF","NOTE_ON","AFTER_TOUCH","CONTROLLER","PROGRAM_CHANGE","CHANNEL_AFTERTOUCH","PITCH_BEND","typeChannelByte","MetaEvent","setData","SEQUENCE","TEXT","COPYRIGHT","TRACK_NAME","INSTRUMENT","LYRIC","MARKER","CUE_POINT","CHANNEL_PREFIX","END_OF_TRACK","TEMPO","SMPTE","TIME_SIG","KEY_SIG","SEQ_EVENT","dataBytes","config","events","START_BYTES","END_BYTES","addEvent","event","addNoteOn","pitch","velocity","addNoteOff","addNote","setInstrument","setTempo","tempo","trackLength","eventBytes","startBytes","endBytes","lengthBytes","tracks","HDR_CHUNKID","HDR_CHUNK_SIZE","HDR_TYPE0","HDR_TYPE1","trackCount","Event","webpackPolyfill","deprecate","paths","children","channel_1","[object Object]","sessionChannels","ch","Channel","channels","startClip","getNextPos","Transport","position","activePatternIdx","channelClips","toMaster","clips","originalParamsFiltered","addClip","stopClip","state","stop","clipParams","activeClipIdx"],"mappings":"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","file":"scribbletune.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scribble\"] = factory();\n\telse\n\t\troot[\"scribble\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tonal_1 = require(\"tonal\");\nconst chordNames = tonal_1.Chord.names();\nconst utils_1 = require(\"./utils\");\n// Since chords like C5 can also qualify for the note C5,\n// Scribbletune treats such chords with the `th` appended to it\nconst numericalChords = {\n    '4th': '4',\n    '5th': '5',\n    '7th': '7',\n    '9th': '9',\n    '11th': '11',\n    '13th': '13',\n};\n/**\n * Derive a chord from the given string. Exposed as simply `chord` in Scribbletune\n * @return {Array}     [example output: ['c4', 'e4', 'g4']]\n */\nexports.getChord = (name) => {\n    if (utils_1.isNote(name)) {\n        throw new Error(`${name} is not a chord!`);\n    }\n    // Separate the octave from the chord\n    const spl = name.split('-'); // e.g. CMaj7-4 => ['CMaj7', '4'];\n    // tonal doesnt recognize 5 and below in the `tokenize` method,\n    // hence explicitly massage those out\n    const tokenizedName = tonal_1.Chord.tokenize(spl[0]); // e.g. ['C', 'Maj7']\n    let root = tokenizedName[0];\n    let chordName = tokenizedName[1];\n    if (root[1] === '4' || root[1] === '5') {\n        chordName = root[1];\n        root = root.replace(/\\d/, '');\n    }\n    if (numericalChords[chordName]) {\n        chordName = numericalChords[chordName];\n    }\n    if (!tonal_1.Chord.exists(chordName)) {\n        throw new TypeError('Invalid chord name: ' + chordName);\n    }\n    return (tonal_1.chord(chordName) || []).map(el => {\n        const note = tonal_1.transpose.bind(null, root + (spl[1] || 4))(el);\n        return tonal_1.Note.simplify(note);\n    });\n};\n/**\n * Get a list of chords available in Scribbletune.\n * @return {Array}     [example output: ['maj', 'min', 'dim']]\n */\nexports.chords = () => {\n    return chordNames.map(c => {\n        if (/^\\d+$/.test(c) && numericalChords[c]) {\n            return numericalChords[c];\n        }\n        else {\n            return c;\n        }\n    });\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Take a string input and check if it s a note name or not\n * @param  {String} str Note name e.g. c4\n * @return {Boolean} Return true for c4 or return false for something like CM\n */\nexports.isNote = (str) => /^[a-gA-G](?:#|b)?\\d$/.test(str);\n/**\n * Take a String input such as xxx[xx[xx]]\n * and return an Array as ['x', 'x', 'x', ['x', 'x', ['x', 'x']]]\n * @param  {String} str\n * @return {Array}\n */\nexports.expandStr = (str) => {\n    str = JSON.stringify(str.split(''));\n    str = str.replace(/,\"\\[\",/g, ', [');\n    str = str.replace(/\"\\[\",/g, '[');\n    str = str.replace(/,\"\\]\"/g, ']');\n    return JSON.parse(str);\n};\n/**\n * Basic Array randomizer\n * @param  {Array} arr\n * @return {Array}\n */\nexports.shuffle = (arr) => {\n    const lastIndex = arr.length - 1;\n    arr.forEach((el, idx) => {\n        const rnd = Math.round(Math.random() * lastIndex);\n        arr[idx] = arr[rnd];\n        arr[rnd] = el;\n    });\n    return arr;\n};\n/**\n * Return an array of numbers relative to maxLevel || 127 ordered in a Sine wave format\n * This is used by the `sizzle` param of the `clip` method to add a rudimentary variation to the accent of each note\n * @param {Number} maxLevel A number between not more than 127\n * @return {Array}  Example output [63, 90, 110, 127, 110, 90, 63, 0, 63, 90, 110, 127, 110, 90, 63, 0]\n */\nexports.sizzleMap = (maxLevel = 127) => {\n    const pi = Math.PI;\n    const piArr = [\n        pi / 6,\n        pi / 4,\n        pi / 3,\n        pi / 2,\n        (2 * pi) / 3,\n        (3 * pi) / 4,\n        (5 * pi) / 6,\n        pi,\n    ];\n    const piArrRev = [\n        0,\n        pi / 6,\n        pi / 4,\n        pi / 3,\n        pi / 2,\n        (2 * pi) / 3,\n        (3 * pi) / 4,\n        (5 * pi) / 6,\n    ];\n    piArrRev.reverse();\n    const arr = piArr.concat(piArrRev);\n    return arr.map(element => Math.round(Math.sin(element) * maxLevel));\n};\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Tonal = __importStar(require(\"tonal\"));\nexports.getScale = (tonicOctScale) => {\n    tonicOctScale = tonicOctScale && tonicOctScale.toLowerCase();\n    // In Tonal, the only scales that are not entirely lower case are\n    // lydian #5P pentatonic and minor #7M pentatonic,\n    // hence make provision for them separately\n    tonicOctScale = tonicOctScale.replace('#5p', '#5P');\n    tonicOctScale = tonicOctScale.replace('#7m', '#7M');\n    const tokenizedName = Tonal.Scale.tokenize(tonicOctScale);\n    const scaleName = tokenizedName[1];\n    if (!Tonal.Scale.exists(scaleName)) {\n        throw new Error(`${tonicOctScale} does not exist!`);\n    }\n    return Tonal.Scale.notes(tonicOctScale).map(Tonal.Note.simplify);\n};\nexports.scales = () => {\n    return Tonal.Scale.names();\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst chord_1 = require(\"./chord\");\n/* tslint:disable:no-var-requires */\nconst browserClip = typeof window !== 'undefined' && require('./browserClip');\n/**\n * Get defauly params for a clip, such as root note, pattern etc\n * @return {Object}\n */\nconst getDefaultParams = () => ({\n    notes: ['C4'],\n    pattern: 'x',\n    shuffle: false,\n    sizzle: false,\n    arpegiate: false,\n    subdiv: '4n',\n});\n/**\n * HDR speed is denoted by the number of ticks per note\n * By default this is set to a quarter note (4n) to be in line with Tone.js' default subdivision\n * Technically a bar is 512 ticks long. So it's HDR speed is 512\n * @type {Object}\n */\nconst hdr = {\n    '1n': 512,\n    '2n': 256,\n    '4n': 128,\n    '8n': 64,\n    '16n': 32,\n};\n/*\nparams = {\n    notes: 'c4',\n    pattern: 'x[x[xx]x]x'\n}\n */\nexports.clip = (params) => {\n    params = { ...getDefaultParams(), ...(params || {}) };\n    // If notes is a string, split it into an array\n    if (typeof params.notes === 'string') {\n        // Remove any accidental double spaces\n        params.notes = params.notes.replace(/\\s{2,}/g, ' ');\n        params.notes = params.notes.split(' ');\n    }\n    // Convert chords if any to notes\n    params.notes = params.notes.map((el) => {\n        if (utils_1.isNote(el)) {\n            // A note needs to be an array so that it can accomodate chords or single notes with a single interface\n            return [el];\n        }\n        if (chord_1.getChord(el)) {\n            // A note such as c6 could be a chord (sixth) or a note (c on the 6th octave)\n            // This also applies to c4, c5, c6, c9, c11\n            // TODO: Identify a way to avoid returning unwanted results\n            el = chord_1.getChord(el);\n        }\n        if (Array.isArray(el)) {\n            // This could be a chord provided as an array\n            // make sure it uses valid notes\n            el.forEach(n => {\n                if (!utils_1.isNote(n)) {\n                    throw new TypeError('array must comprise valid notes');\n                }\n            });\n        }\n        return el;\n    });\n    if (/[^x\\-_\\[\\]]/.test(params.pattern)) {\n        throw new TypeError(`pattern can only comprise x - _ [ ], found ${params.pattern}`);\n    }\n    if (params.shuffle) {\n        params.notes = utils_1.shuffle(params.notes);\n    }\n    // If the clip method is being called in the context of a Tone.js instrument or synth,\n    // then there's no need to continue\n    if (params.synth ||\n        params.instrument ||\n        params.sample ||\n        params.player ||\n        params.samples ||\n        params.sampler) {\n        return browserClip(params);\n    }\n    const clipNotes = [];\n    let step = 0;\n    /**\n     * Recursively apply pattern to notes\n     *\n     * Pass in a pattern array such as ['x', '-', 'x', 'x'] with a length for each element\n     * The length is the HDR speed or tick length (obtained from the hdr object in this script)\n     * If the element of this array is also a (pattern) array, then divide the length by\n     * the length of the inner array and then call the recursive function on that inner array\n     */\n    const recursivelyApplyPatternToNotes = (arr, length) => {\n        arr.forEach(el => {\n            if (typeof el === 'string') {\n                let note = [];\n                // If the note is to be `on`, then it needs to be an array\n                if (el === 'x') {\n                    note = params.notes[step];\n                    step++;\n                }\n                // Push only note on OR off messages to the clip notes array\n                if (el === 'x' || el === '-') {\n                    clipNotes.push({ note, length, level: 127 });\n                }\n                // In case of an underscore, simply extend the previous note's length\n                if (el === '_' && clipNotes.length) {\n                    clipNotes[clipNotes.length - 1].length += length;\n                }\n                // If the pattern is longer than the notes, then repeat notes\n                if (step === params.notes.length) {\n                    step = 0;\n                }\n            }\n            if (Array.isArray(el)) {\n                recursivelyApplyPatternToNotes(el, length / el.length);\n            }\n        });\n    };\n    recursivelyApplyPatternToNotes(utils_1.expandStr(params.pattern), hdr[params.subdiv] || hdr['4n']);\n    return clipNotes;\n};\n","var NAMES = \"C C# Db D D# Eb E F F# Gb G G# Ab A A# Bb B\".split(\" \");\r\nvar names = function (accTypes) {\r\n    return typeof accTypes !== \"string\"\r\n        ? NAMES.slice()\r\n        : NAMES.filter(function (n) {\r\n            var acc = n[1] || \" \";\r\n            return accTypes.indexOf(acc) !== -1;\r\n        });\r\n};\r\nvar SHARPS = names(\" #\");\r\nvar FLATS = names(\" b\");\r\nvar REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\r\nfunction tokenize(str) {\r\n    if (typeof str !== \"string\")\r\n        str = \"\";\r\n    var m = REGEX.exec(str);\r\n    return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\r\n}\r\nvar NO_NOTE = Object.freeze({\r\n    pc: null,\r\n    name: null,\r\n    step: null,\r\n    alt: null,\r\n    oct: null,\r\n    octStr: null,\r\n    chroma: null,\r\n    midi: null,\r\n    freq: null\r\n});\r\nvar SEMI = [0, 2, 4, 5, 7, 9, 11];\r\nvar properties = function (str) {\r\n    var tokens = tokenize(str);\r\n    if (tokens[0] === \"\" || tokens[3] !== \"\")\r\n        return NO_NOTE;\r\n    var letter = tokens[0], acc = tokens[1], octStr = tokens[2];\r\n    var p = {\r\n        letter: letter,\r\n        acc: acc,\r\n        octStr: octStr,\r\n        pc: letter + acc,\r\n        name: letter + acc + octStr,\r\n        step: (letter.charCodeAt(0) + 3) % 7,\r\n        alt: acc[0] === \"b\" ? -acc.length : acc.length,\r\n        oct: octStr.length ? +octStr : null,\r\n        chroma: 0,\r\n        midi: null,\r\n        freq: null\r\n    };\r\n    p.chroma = (SEMI[p.step] + p.alt + 120) % 12;\r\n    p.midi = p.oct !== null ? SEMI[p.step] + p.alt + 12 * (p.oct + 1) : null;\r\n    p.freq = midiToFreq(p.midi);\r\n    return Object.freeze(p);\r\n};\r\nvar memo = function (fn, cache) {\r\n    if (cache === void 0) { cache = {}; }\r\n    return function (str) { return cache[str] || (cache[str] = fn(str)); };\r\n};\r\nvar props = memo(properties);\r\nvar name = function (str) { return props(str).name; };\r\nvar pc = function (str) { return props(str).pc; };\r\nvar isMidiRange = function (m) { return m >= 0 && m <= 127; };\r\nvar midi = function (note) {\r\n    if (typeof note !== \"number\" && typeof note !== \"string\") {\r\n        return null;\r\n    }\r\n    var midi = props(note).midi;\r\n    var value = midi || midi === 0 ? midi : +note;\r\n    return isMidiRange(value) ? value : null;\r\n};\r\nvar midiToFreq = function (midi, tuning) {\r\n    if (tuning === void 0) { tuning = 440; }\r\n    return typeof midi === \"number\" ? Math.pow(2, (midi - 69) / 12) * tuning : null;\r\n};\r\nvar freq = function (note) { return props(note).freq || midiToFreq(note); };\r\nvar L2 = Math.log(2);\r\nvar L440 = Math.log(440);\r\nvar freqToMidi = function (freq) {\r\n    var v = (12 * (Math.log(freq) - L440)) / L2 + 69;\r\n    return Math.round(v * 100) / 100;\r\n};\r\nvar chroma = function (str) { return props(str).chroma; };\r\nvar oct = function (str) { return props(str).oct; };\r\nvar LETTERS = \"CDEFGAB\";\r\nvar stepToLetter = function (step) { return LETTERS[step]; };\r\nvar fillStr = function (s, n) { return Array(n + 1).join(s); };\r\nvar numToStr = function (num, op) {\r\n    return typeof num !== \"number\" ? \"\" : op(num);\r\n};\r\nvar altToAcc = function (alt) {\r\n    return numToStr(alt, function (alt) { return (alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt)); });\r\n};\r\nvar from = function (fromProps, baseNote) {\r\n    if (fromProps === void 0) { fromProps = {}; }\r\n    if (baseNote === void 0) { baseNote = null; }\r\n    var _a = baseNote\r\n        ? Object.assign({}, props(baseNote), fromProps)\r\n        : fromProps, step = _a.step, alt = _a.alt, oct = _a.oct;\r\n    if (typeof step !== \"number\")\r\n        return null;\r\n    var letter = stepToLetter(step);\r\n    if (!letter)\r\n        return null;\r\n    var pc = letter + altToAcc(alt);\r\n    return oct || oct === 0 ? pc + oct : pc;\r\n};\r\nvar build = from;\r\nfunction fromMidi(num, sharps) {\r\n    if (sharps === void 0) { sharps = false; }\r\n    num = Math.round(num);\r\n    var pcs = sharps === true ? SHARPS : FLATS;\r\n    var pc = pcs[num % 12];\r\n    var o = Math.floor(num / 12) - 1;\r\n    return pc + o;\r\n}\r\nvar simplify = function (note, sameAcc) {\r\n    if (sameAcc === void 0) { sameAcc = true; }\r\n    var _a = props(note), alt = _a.alt, chroma = _a.chroma, midi = _a.midi;\r\n    if (chroma === null)\r\n        return null;\r\n    var alteration = alt;\r\n    var useSharps = sameAcc === false ? alteration < 0 : alteration > 0;\r\n    return midi === null\r\n        ? pc(fromMidi(chroma, useSharps))\r\n        : fromMidi(midi, useSharps);\r\n};\r\nvar enharmonic = function (note) { return simplify(note, false); };\n\nexport { names, tokenize, props, name, pc, midi, midiToFreq, freq, freqToMidi, chroma, oct, stepToLetter, altToAcc, from, build, fromMidi, simplify, enharmonic };\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-array.svg?style=flat-square)](https://www.npmjs.com/package/tonal-array)\n *\n * Tonal array utilities. Create ranges, sort notes, ...\n *\n * @example\n * import * as Array;\n * Array.sort([\"f\", \"a\", \"c\"]) // => [\"C\", \"F\", \"A\"]\n *\n * @example\n * const Array = require(\"tonal-array\")\n * Array.range(1, 4) // => [1, 2, 3, 4]\n *\n * @module Array\n */\nimport { props, name } from \"tonal-note\";\n\n// ascending range\nfunction ascR(b, n) {\n  for (var a = []; n--; a[n] = n + b){ ; }\n  return a;\n}\n// descending range\nfunction descR(b, n) {\n  for (var a = []; n--; a[n] = b - n){ ; }\n  return a;\n}\n\n/**\n * Create a numeric range\n *\n * @param {Number} from\n * @param {Number} to\n * @return {Array}\n *\n * @example\n * Array.range(-2, 2) // => [-2, -1, 0, 1, 2]\n * Array.range(2, -2) // => [2, 1, 0, -1, -2]\n */\nexport function range(a, b) {\n  return a === null || b === null\n    ? []\n    : a < b\n      ? ascR(a, b - a + 1)\n      : descR(a, a - b + 1);\n}\n/**\n *\n * Rotates a list a number of times. It\"s completly agnostic about the\n * contents of the list.\n *\n * @param {Integer} times - the number of rotations\n * @param {Array} array\n * @return {Array} the rotated array\n * @example\n * Array.rotate(1, [1, 2, 3]) // => [2, 3, 1]\n */\nexport function rotate(times, arr) {\n  var len = arr.length;\n  var n = ((times % len) + len) % len;\n  return arr.slice(n, len).concat(arr.slice(0, n));\n}\n\n/**\n * Return a copy of the array with the null values removed\n * @function\n * @param {Array} array\n * @return {Array}\n *\n * @example\n * Array.compact([\"a\", \"b\", null, \"c\"]) // => [\"a\", \"b\", \"c\"]\n */\nexport var compact = function (arr) { return arr.filter(function (n) { return n === 0 || n; }); };\n\n// a function that get note heights (with negative number for pitch classes)\nvar height = function (name) {\n  var m = props(name).midi;\n  return m !== null ? m : props(name + \"-100\").midi;\n};\n\n/**\n * Sort an array of notes in ascending order\n *\n * @param {String|Array} notes\n * @return {Array} sorted array of notes\n */\nexport function sort(src) {\n  return compact(src.map(name)).sort(function (a, b) { return height(a) > height(b); });\n}\n\n/**\n * Get sorted notes with duplicates removed\n *\n * @function\n * @param {Array} notes\n */\nexport function unique(arr) {\n  return sort(arr).filter(function (n, i, a) { return i === 0 || n !== a[i - 1]; });\n}\n\n/**\n * Randomizes the order of the specified array in-place, using the Fisher–Yates shuffle.\n *\n * @private\n * @function\n * @param {Array|String} arr - the array\n * @return {Array} the shuffled array\n *\n * @example\n * Array.shuffle([\"C\", \"D\", \"E\", \"F\"])\n */\nexport var shuffle = function (arr, rnd) {\n  if ( rnd === void 0 ) rnd = Math.random;\n\n  var i, t;\n  var m = arr.length;\n  while (m) {\n    i = (rnd() * m--) | 0;\n    t = arr[m];\n    arr[m] = arr[i];\n    arr[i] = t;\n  }\n  return arr;\n};\n\n/**\n * Get all permutations of an array\n * http://stackoverflow.com/questions/9960908/permutations-in-javascript\n *\n * @param {Array} array - the array\n * @return {Array<Array>} an array with all the permutations\n */\nexport var permutations = function (arr) {\n  if (arr.length === 0) { return [[]]; }\n  return permutations(arr.slice(1)).reduce(function(acc, perm) {\n    return acc.concat(\n      arr.map(function(e, pos) {\n        var newPerm = perm.slice();\n        newPerm.splice(pos, 0, arr[0]);\n        return newPerm;\n      })\n    );\n  }, []);\n};\n","var IVL_TNL = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\r\nvar IVL_STR = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\r\nvar REGEX = new RegExp(\"^\" + IVL_TNL + \"|\" + IVL_STR + \"$\");\r\nvar SIZES = [0, 2, 4, 5, 7, 9, 11];\r\nvar TYPES = \"PMMPPMM\";\r\nvar CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];\r\nvar NAMES = \"1P 2m 2M 3m 3M 4P 5P 6m 6M 7m 7M 8P\".split(\" \");\r\nvar names = function (types) {\r\n    return typeof types !== \"string\"\r\n        ? NAMES.slice()\r\n        : NAMES.filter(function (n) { return types.indexOf(n[1]) !== -1; });\r\n};\r\nvar tokenize = function (str) {\r\n    var m = REGEX.exec(\"\" + str);\r\n    if (m === null)\r\n        return null;\r\n    return (m[1] ? [m[1], m[2]] : [m[4], m[3]]);\r\n};\r\nvar NO_IVL = Object.freeze({\r\n    name: null,\r\n    num: null,\r\n    q: null,\r\n    step: null,\r\n    alt: null,\r\n    dir: null,\r\n    type: null,\r\n    simple: null,\r\n    semitones: null,\r\n    chroma: null,\r\n    oct: null\r\n});\r\nvar fillStr = function (s, n) { return Array(Math.abs(n) + 1).join(s); };\r\nvar qToAlt = function (type, q) {\r\n    if (q === \"M\" && type === \"M\")\r\n        return 0;\r\n    if (q === \"P\" && type === \"P\")\r\n        return 0;\r\n    if (q === \"m\" && type === \"M\")\r\n        return -1;\r\n    if (/^A+$/.test(q))\r\n        return q.length;\r\n    if (/^d+$/.test(q))\r\n        return type === \"P\" ? -q.length : -q.length - 1;\r\n    return null;\r\n};\r\nvar altToQ = function (type, alt) {\r\n    if (alt === 0)\r\n        return type === \"M\" ? \"M\" : \"P\";\r\n    else if (alt === -1 && type === \"M\")\r\n        return \"m\";\r\n    else if (alt > 0)\r\n        return fillStr(\"A\", alt);\r\n    else if (alt < 0)\r\n        return fillStr(\"d\", type === \"P\" ? alt : alt + 1);\r\n    else\r\n        return null;\r\n};\r\nvar numToStep = function (num) { return (Math.abs(num) - 1) % 7; };\r\nvar properties = function (str) {\r\n    var t = tokenize(str);\r\n    if (t === null)\r\n        return NO_IVL;\r\n    var p = {\r\n        num: 0,\r\n        q: \"d\",\r\n        name: \"\",\r\n        type: \"M\",\r\n        step: 0,\r\n        dir: -1,\r\n        simple: 1,\r\n        alt: 0,\r\n        oct: 0,\r\n        semitones: 0,\r\n        chroma: 0,\r\n        ic: 0\r\n    };\r\n    p.num = +t[0];\r\n    p.q = t[1];\r\n    p.step = numToStep(p.num);\r\n    p.type = TYPES[p.step];\r\n    if (p.type === \"M\" && p.q === \"P\")\r\n        return NO_IVL;\r\n    p.name = \"\" + p.num + p.q;\r\n    p.dir = p.num < 0 ? -1 : 1;\r\n    p.simple = (p.num === 8 || p.num === -8\r\n        ? p.num\r\n        : p.dir * (p.step + 1));\r\n    p.alt = qToAlt(p.type, p.q);\r\n    p.oct = Math.floor((Math.abs(p.num) - 1) / 7);\r\n    p.semitones = p.dir * (SIZES[p.step] + p.alt + 12 * p.oct);\r\n    p.chroma = ((((p.dir * (SIZES[p.step] + p.alt)) % 12) + 12) %\r\n        12);\r\n    return Object.freeze(p);\r\n};\r\nvar cache = {};\r\nfunction props(str) {\r\n    if (typeof str !== \"string\")\r\n        return NO_IVL;\r\n    return cache[str] || (cache[str] = properties(str));\r\n}\r\nvar num = function (str) { return props(str).num; };\r\nvar name = function (str) { return props(str).name; };\r\nvar semitones = function (str) { return props(str).semitones; };\r\nvar chroma = function (str) { return props(str).chroma; };\r\nvar ic = function (ivl) {\r\n    if (typeof ivl === \"string\")\r\n        ivl = props(ivl).chroma;\r\n    return typeof ivl === \"number\" ? CLASSES[ivl % 12] : null;\r\n};\r\nvar build = function (_a) {\r\n    var _b = _a === void 0 ? {} : _a, num = _b.num, step = _b.step, alt = _b.alt, _c = _b.oct, oct = _c === void 0 ? 1 : _c, dir = _b.dir;\r\n    if (step !== undefined)\r\n        num = step + 1 + 7 * oct;\r\n    if (num === undefined)\r\n        return null;\r\n    if (typeof alt !== \"number\")\r\n        return null;\r\n    var d = typeof dir !== \"number\" ? \"\" : dir < 0 ? \"-\" : \"\";\r\n    var type = TYPES[numToStep(num)];\r\n    return (d + num + altToQ(type, alt));\r\n};\r\nvar simplify = function (str) {\r\n    var p = props(str);\r\n    if (p === NO_IVL)\r\n        return null;\r\n    var intervalProps = p;\r\n    return intervalProps.simple + intervalProps.q;\r\n};\r\nvar invert = function (str) {\r\n    var p = props(str);\r\n    if (p === NO_IVL)\r\n        return null;\r\n    var intervalProps = p;\r\n    var step = (7 - intervalProps.step) % 7;\r\n    var alt = intervalProps.type === \"P\" ? -intervalProps.alt : -(intervalProps.alt + 1);\r\n    return build({ step: step, alt: alt, oct: intervalProps.oct, dir: intervalProps.dir });\r\n};\r\nvar IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\r\nvar IQ = \"P m M m M P d P m M m M\".split(\" \");\r\nvar fromSemitones = function (num) {\r\n    var d = num < 0 ? -1 : 1;\r\n    var n = Math.abs(num);\r\n    var c = n % 12;\r\n    var o = Math.floor(n / 12);\r\n    return d * (IN[c] + 7 * o) + IQ[c];\r\n};\n\nexport { names, tokenize, qToAlt, altToQ, props, num, name, semitones, chroma, ic, build, simplify, invert, fromSemitones };\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)\n * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)\n *\n * Transpose notes by intervals and find distances between notes\n *\n * @example\n * // es6\n * import * as Distance from \"tonal-distance\"\n * Distance.interval(\"C3\", \"C4\") // => \"1P\"\n *\n * @example\n * // es6 import selected functions\n * import { interval, semitones, transpose } from \"tonal-distance\"\n *\n * semitones(\"C\" ,\"D\") // => 2\n * interval(\"C4\", \"G4\") // => \"5P\"\n * transpose(\"C4\", \"P5\") // => \"G4\"\n *\n * @example\n * // included in tonal facade\n * const Tonal = require(\"tonal\");\n * Tonal.Distance.transpose(\"C4\", \"P5\")\n * Tonal.Distance.transposeBy(\"P5\", \"C4\")\n *\n * @module Distance\n */\nimport { props as noteProps, build as fromNote } from \"tonal-note\";\nimport { props as iprops, build as ibuild } from \"tonal-interval\";\n\n// Map from letter step to number of fifths starting from \"C\":\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n\n// Given a number of fifths, return the octaves they span\nvar fOcts = function (f) { return Math.floor((f * 7) / 12); };\n\n// Get the number of octaves it span each step\nvar FIFTH_OCTS = FIFTHS.map(fOcts);\n\nvar encode = function (ref) {\n  var step = ref.step;\n  var alt = ref.alt;\n  var oct = ref.oct;\n  var dir = ref.dir; if ( dir === void 0 ) dir = 1;\n\n  var f = FIFTHS[step] + 7 * alt;\n  if (oct === null) { return [dir * f]; }\n  var o = oct - FIFTH_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n};\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\nvar STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f) {\n  var i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\nvar decode = function (f, o, dir) {\n  var step = STEPS[unaltered(f)];\n  var alt = Math.floor((f + 1) / 7);\n  if (o === undefined) { return { step: step, alt: alt, dir: dir }; }\n  var oct = o + 4 * alt + FIFTH_OCTS[step];\n  return { step: step, alt: alt, oct: oct, dir: dir };\n};\n\nvar memo = function (fn, cache) {\n  if ( cache === void 0 ) cache = {};\n\n  return function (str) { return cache[str] || (cache[str] = fn(str)); };\n};\n\nvar encoder = function (props) { return memo(function (str) {\n    var p = props(str);\n    return p.name === null ? null : encode(p);\n  }); };\n\nvar encodeNote = encoder(noteProps);\nvar encodeIvl = encoder(iprops);\n\n/**\n * Transpose a note by an interval. The note can be a pitch class.\n *\n * This function can be partially applied.\n *\n * @param {string} note\n * @param {string} interval\n * @return {string} the transposed note\n * @example\n * import { tranpose } from \"tonal-distance\"\n * transpose(\"d3\", \"3M\") // => \"F#3\"\n * // it works with pitch classes\n * transpose(\"D\", \"3M\") // => \"F#\"\n * // can be partially applied\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(transpose(\"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\n */\nexport function transpose(note, interval) {\n  if (arguments.length === 1) { return function (i) { return transpose(note, i); }; }\n  var n = encodeNote(note);\n  var i = encodeIvl(interval);\n  if (n === null || i === null) { return null; }\n  var tr = n.length === 1 ? [n[0] + i[0]] : [n[0] + i[0], n[1] + i[1]];\n  return fromNote(decode(tr[0], tr[1]));\n}\n\n/**\n * Transpose a pitch class by a number of perfect fifths.\n *\n * It can be partially applied.\n *\n * @function\n * @param {string} pitchClass - the pitch class\n * @param {Integer} fifhts - the number of fifths\n * @return {string} the transposed pitch class\n *\n * @example\n * import { trFifths } from \"tonal-transpose\"\n * [0, 1, 2, 3, 4].map(trFifths(\"C\")) // => [\"C\", \"G\", \"D\", \"A\", \"E\"]\n * // or using tonal\n * Distance.trFifths(\"G4\", 1) // => \"D\"\n */\n\nexport function trFifths(note, fifths) {\n  if (arguments.length === 1) { return function (f) { return trFifths(note, f); }; }\n  var n = encodeNote(note);\n  if (n === null) { return null; }\n  return fromNote(decode(n[0] + fifths));\n}\n\n/**\n * Get the distance in fifths between pitch classes\n *\n * Can be partially applied.\n *\n * @param {string} to - note or pitch class\n * @param {string} from - note or pitch class\n */\nexport function fifths(from, to) {\n  if (arguments.length === 1) { return function (to) { return fifths(from, to); }; }\n  var f = encodeNote(from);\n  var t = encodeNote(to);\n  if (t === null || f === null) { return null; }\n  return t[0] - f[0];\n}\n\n/**\n * The same as transpose with the arguments inverted.\n *\n * Can be partially applied.\n *\n * @param {string} note\n * @param {string} interval\n * @return {string} the transposed note\n * @example\n * import { tranposeBy } from \"tonal-distance\"\n * transposeBy(\"3m\", \"5P\") // => \"7m\"\n */\nexport function transposeBy(interval, note) {\n  if (arguments.length === 1) { return function (n) { return transpose(n, interval); }; }\n  return transpose(note, interval);\n}\n\nvar isDescending = function (e) { return e[0] * 7 + e[1] * 12 < 0; };\nvar decodeIvl = function (i) { return isDescending(i) ? decode(-i[0], -i[1], -1) : decode(i[0], i[1], 1); };\n\nexport function addIntervals(ivl1, ivl2, dir) {\n  var i1 = encodeIvl(ivl1);\n  var i2 = encodeIvl(ivl2);\n  if (i1 === null || i2 === null) { return null; }\n  var i = [i1[0] + dir * i2[0], i1[1] + dir * i2[1]];\n  return ibuild(decodeIvl(i));\n}\n\n/**\n * Add two intervals\n *\n * Can be partially applied.\n *\n * @param {string} interval1\n * @param {string} interval2\n * @return {string} the resulting interval\n * @example\n * import { add } from \"tonal-distance\"\n * add(\"3m\", \"5P\") // => \"7m\"\n */\nexport function add(ivl1, ivl2) {\n  if (arguments.length === 1) { return function (i2) { return add(ivl1, i2); }; }\n  return addIntervals(ivl1, ivl2, 1);\n}\n\n/**\n * Subtract two intervals\n *\n * Can be partially applied\n *\n * @param {string} minuend\n * @param {string} subtrahend\n * @return {string} interval diference\n */\nexport function subtract(ivl1, ivl2) {\n  if (arguments.length === 1) { return function (i2) { return add(ivl1, i2); }; }\n  return addIntervals(ivl1, ivl2, -1);\n}\n\n/**\n * Find the interval between two pitches. It works with pitch classes\n * (both must be pitch classes and the interval is always ascending)\n *\n * Can be partially applied\n *\n * @param {string} from - distance from\n * @param {string} to - distance to\n * @return {string} the interval distance\n *\n * @example\n * import { interval } from \"tonal-distance\"\n * interval(\"C2\", \"C3\") // => \"P8\"\n * interval(\"G\", \"B\") // => \"M3\"\n *\n * @example\n * import * as Distance from \"tonal-distance\"\n * Distance.interval(\"M2\", \"P5\") // => \"P4\"\n */\nexport function interval(from, to) {\n  if (arguments.length === 1) { return function (t) { return interval(from, t); }; }\n  var f = encodeNote(from);\n  var t = encodeNote(to);\n  if (f === null || t === null || f.length !== t.length) { return null; }\n  var d =\n    f.length === 1\n      ? [t[0] - f[0], -Math.floor(((t[0] - f[0]) * 7) / 12)]\n      : [t[0] - f[0], t[1] - f[1]];\n  return ibuild(decodeIvl(d));\n}\n\n/**\n * Get the distance between two notes in semitones\n *\n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { semitones } from \"tonal-distance\"\n * semitones(\"C3\", \"A2\") // => -3\n * // or use tonal\n * Tonal.Distance.semitones(\"C3\", \"G3\") // => 7\n */\nexport function semitones(from, to) {\n  if (arguments.length === 1) { return function (t) { return semitones(from, t); }; }\n  var f = noteProps(from);\n  var t = noteProps(to);\n  return f.midi !== null && t.midi !== null\n    ? t.midi - f.midi\n    : f.chroma !== null && t.chroma !== null\n      ? (t.chroma - f.chroma + 12) % 12\n      : null;\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)\n * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented\n * to make comparations (isEqual, isSubset, isSuperset)\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * You can install via npm: `npm i --save tonal-pcset`\n *\n * ```js\n * // es6\n * import PcSet from \"tonal-pcset\"\n * var PcSet = require(\"tonal-pcset\")\n *\n * PcSet.isEqual(\"c2 d5 e6\", \"c6 e3 d1\") // => true\n * ```\n *\n * ## API documentation\n *\n * @module PcSet\n */\nimport { chroma as notechr } from \"tonal-note\";\nimport { chroma as ivlchr } from \"tonal-interval\";\nimport { rotate, range, compact } from \"tonal-array\";\n\nvar chr = function (str) { return notechr(str) || ivlchr(str) || 0; };\nvar pcsetNum = function (set) { return parseInt(chroma(set), 2); };\nvar clen = function (chroma) { return chroma.replace(/0/g, \"\").length; };\n\n/**\n * Get chroma of a pitch class set. A chroma identifies each set uniquely.\n * It\"s a 12-digit binary each presenting one semitone of the octave.\n *\n * Note that this function accepts a chroma as parameter and return it\n * without modification.\n *\n * @param {Array|String} set - the pitch class set\n * @return {string} a binary representation of the pitch class set\n * @example\n * PcSet.chroma([\"C\", \"D\", \"E\"]) // => \"1010100000000\"\n */\nexport function chroma(set) {\n  if (isChroma(set)) { return set; }\n  if (!Array.isArray(set)) { return \"\"; }\n  var b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  set.map(chr).forEach(function (i) {\n    b[i] = 1;\n  });\n  return b.join(\"\");\n}\n\nvar all = null;\n/**\n * Get a list of all possible chromas (all possible scales)\n * More information: http://allthescales.org/\n * @return {Array} an array of possible chromas from '10000000000' to '11111111111'\n *\n */\nexport function chromas(n) {\n  all = all || range(2048, 4095).map(function (n) { return n.toString(2); });\n  return typeof n === \"number\"\n    ? all.filter(function (chroma) { return clen(chroma) === n; })\n    : all.slice();\n}\n\n/**\n * Given a a list of notes or a pcset chroma, produce the rotations\n * of the chroma discarding the ones that starts with \"0\"\n *\n * This is used, for example, to get all the modes of a scale.\n *\n * @param {Array|String} set - the list of notes or pitchChr of the set\n * @param {Boolean} normalize - (Optional, true by default) remove all\n * the rotations that starts with \"0\"\n * @return {Array<String>} an array with all the modes of the chroma\n *\n * @example\n * PcSet.modes([\"C\", \"D\", \"E\"]).map(PcSet.intervals)\n */\nexport function modes(set, normalize) {\n  normalize = normalize !== false;\n  var binary = chroma(set).split(\"\");\n  return compact(\n    binary.map(function(_, i) {\n      var r = rotate(i, binary);\n      return normalize && r[0] === \"0\" ? null : r.join(\"\");\n    })\n  );\n}\n\nvar REGEX = /^[01]{12}$/;\n/**\n * Test if the given string is a pitch class set chroma.\n * @param {string} chroma - the pitch class set chroma\n * @return {Boolean} true if its a valid pcset chroma\n * @example\n * PcSet.isChroma(\"101010101010\") // => true\n * PcSet.isChroma(\"101001\") // => false\n */\nexport function isChroma(set) {\n  return REGEX.test(set);\n}\n\nvar IVLS = \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n/**\n * Given a pcset (notes or chroma) return it\"s intervals\n * @param {String|Array} pcset - the pitch class set (notes or chroma)\n * @return {Array} intervals or empty array if not valid pcset\n * @example\n * PcSet.intervals(\"1010100000000\") => [\"1P\", \"2M\", \"3M\"]\n */\nexport function intervals(set) {\n  if (!isChroma(set)) { return []; }\n  return compact(\n    set.split(\"\").map(function(d, i) {\n      return d === \"1\" ? IVLS[i] : null;\n    })\n  );\n}\n\n/**\n * Test if two pitch class sets are identical\n *\n * @param {Array|String} set1 - one of the pitch class sets\n * @param {Array|String} set2 - the other pitch class set\n * @return {Boolean} true if they are equal\n * @example\n * PcSet.isEqual([\"c2\", \"d3\"], [\"c5\", \"d2\"]) // => true\n */\nexport function isEqual(s1, s2) {\n  if (arguments.length === 1) { return function (s) { return isEqual(s1, s); }; }\n  return chroma(s1) === chroma(s2);\n}\n\n/**\n * Create a function that test if a collection of notes is a\n * subset of a given set\n *\n * The function can be partially applied\n *\n * @param {Array|String} set - an array of notes or a chroma set string to test against\n * @param {Array|String} notes - an array of notes or a chroma set\n * @return {boolean} true if notes is a subset of set, false otherwise\n * @example\n * const inCMajor = PcSet.isSubsetOf([\"C\", \"E\", \"G\"])\n * inCMajor([\"e6\", \"c4\"]) // => true\n * inCMajor([\"e6\", \"c4\", \"d3\"]) // => false\n */\nexport function isSubsetOf(set, notes) {\n  if (arguments.length > 1) { return isSubsetOf(set)(notes); }\n  set = pcsetNum(set);\n  return function(notes) {\n    notes = pcsetNum(notes);\n    return notes !== set && (notes & set) === notes;\n  };\n}\n\n/**\n * Create a function that test if a collectio of notes is a\n * superset of a given set (it contains all notes and at least one more)\n *\n * @param {Array|String} set - an array of notes or a chroma set string to test against\n * @param {Array|String} notes - an array of notes or a chroma set\n * @return {boolean} true if notes is a superset of set, false otherwise\n * @example\n * const extendsCMajor = PcSet.isSupersetOf([\"C\", \"E\", \"G\"])\n * extendsCMajor([\"e6\", \"a\", \"c4\", \"g2\"]) // => true\n * extendsCMajor([\"c6\", \"e4\", \"g3\"]) // => false\n */\nexport function isSupersetOf(set, notes) {\n  if (arguments.length > 1) { return isSupersetOf(set)(notes); }\n  set = pcsetNum(set);\n  return function(notes) {\n    notes = pcsetNum(notes);\n    return notes !== set && (notes | set) === notes;\n  };\n}\n\n/**\n * Test if a given pitch class set includes a note\n * @param {Array|String} set - the base set to test against\n * @param {String|Pitch} note - the note to test\n * @return {Boolean} true if the note is included in the pcset\n * @example\n * PcSet.includes([\"C\", \"D\", \"E\"], \"C4\") // => true\n * PcSet.includes([\"C\", \"D\", \"E\"], \"C#4\") // => false\n */\nexport function includes(set, note) {\n  if (arguments.length > 1) { return includes(set)(note); }\n  set = chroma(set);\n  return function(note) {\n    return set[chr(note)] === \"1\";\n  };\n}\n\n/**\n * Filter a list with a pitch class set\n *\n * @param {Array|String} set - the pitch class set notes\n * @param {Array|String} notes - the note list to be filtered\n * @return {Array} the filtered notes\n *\n * @example\n * PcSet.filter([\"C\", \"D\", \"E\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"d2\", \"c3\", \"d3\" ])\n * PcSet.filter([\"C2\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"c3\" ])\n */\nexport function filter(set, notes) {\n  if (arguments.length === 1) { return function (n) { return filter(set, n); }; }\n  return notes.filter(includes(set));\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-dictionary.svg)](https://www.npmjs.com/package/tonal-dictionary)\n *\n * `tonal-dictionary` contains a dictionary of musical scales and chords\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * // es6\n * import * as Dictionary from \"tonal-dictionary\"\n * // es5\n * const Dictionary = require(\"tonal-dictionary\")\n *\n * @example\n * Dictionary.chord(\"Maj7\") // => [\"1P\", \"3M\", \"5P\", \"7M\"]\n *\n * @module Dictionary\n */\nimport sdata from \"./data/scales.json\";\nimport cdata from \"./data/chords.json\";\nimport { chroma } from \"tonal-pcset\";\n\nexport var dictionary = function (raw) {\n  var keys = Object.keys(raw).sort();\n  var data = [];\n  var index = [];\n\n  var add = function (name, ivls, chroma) {\n    data[name] = ivls;\n    index[chroma] = index[chroma] || [];\n    index[chroma].push(name);\n  };\n\n  keys.forEach(function (key) {\n    var ivls = raw[key][0].split(\" \");\n    var alias = raw[key][1];\n    var chr = chroma(ivls);\n\n    add(key, ivls, chr);\n    if (alias) { alias.forEach(function (a) { return add(a, ivls, chr); }); }\n  });\n  var allKeys = Object.keys(data).sort();\n\n  var dict = function (name) { return data[name]; };\n  dict.names = function (p) {\n    if (typeof p === \"string\") { return (index[p] || []).slice(); }\n    else { return (p === true ? allKeys : keys).slice(); }\n  };\n  return dict;\n};\n\nexport var combine = function (a, b) {\n  var dict = function (name) { return a(name) || b(name); };\n  dict.names = function (p) { return a.names(p).concat(b.names(p)); };\n  return dict;\n};\n\n/**\n * A dictionary of scales: a function that given a scale name (without tonic)\n * returns an array of intervals\n *\n * @function\n * @param {string} name\n * @return {Array} intervals\n * @example\n * import { scale } from \"tonal-dictionary\"\n * scale(\"major\") // => [\"1P\", \"2M\", ...]\n * scale.names(); // => [\"major\", ...]\n */\nexport var scale = dictionary(sdata);\n\n/**\n * A dictionary of chords: a function that given a chord type\n * returns an array of intervals\n *\n * @function\n * @param {string} type\n * @return {Array} intervals\n * @example\n * import { chord } from \"tonal-dictionary\"\n * chord(\"Maj7\") // => [\"1P\", \"3M\", ...]\n * chord.names(); // => [\"Maj3\", ...]\n */\nexport var chord = dictionary(cdata);\nexport var pcset = combine(scale, chord);\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-scale.svg?style=flat-square)](https://www.npmjs.com/package/tonal-scale)\n *\n * A scale is a collection of pitches in ascending or descending order.\n *\n * This module provides functions to get and manipulate scales.\n *\n * @example\n * // es6\n * import * as Scale from \"tonal-scale\"\n * // es5\n * const Scale = require(\"tonal-scale\");\n *\n * @example\n * Scale.notes(\"Ab bebop\") // => [ \"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"Gb\", \"G\" ]\n * Scale.names() => [\"major\", \"minor\", ...]\n * @module Scale\n */\nimport { name as noteName, pc } from \"tonal-note\";\nimport {\n  modes as pcsetModes,\n  chroma,\n  isSubsetOf,\n  isSupersetOf\n} from \"tonal-pcset\";\nimport { transpose } from \"tonal-distance\";\nimport { scale, chord } from \"tonal-dictionary\";\nimport { compact, unique, rotate } from \"tonal-array\";\n\nvar NO_SCALE = Object.freeze({\n  name: null,\n  intervals: [],\n  names: [],\n  chroma: null,\n  setnum: null\n});\n\nvar properties = function (name) {\n  var intervals = scale(name);\n  if (!intervals) { return NO_SCALE; }\n  var s = { intervals: intervals, name: name };\n  s.chroma = chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = scale.names(s.chroma);\n  return Object.freeze(s);\n};\n\nvar memoize = function (fn, cache) { return function (str) { return cache[str] || (cache[str] = fn(str)); }; };\n\n/**\n * Get scale properties. It returns an object with:\n * - name: the scale name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the scale intervals\n * - chroma:  scale croma (see pcset)\n * - setnum: scale chroma number\n *\n * @function\n * @param {string} name - the scale name (without tonic)\n * @return {Object}\n */\nexport var props = memoize(properties, {});\n\n/**\n * Return the available scale names\n *\n * @function\n * @param {boolean} [aliases=false] - true to include aliases\n * @return {Array} the scale names\n *\n * @example\n * Scale.names() // => [\"maj7\", ...]\n */\nexport var names = scale.names;\n\n/**\n * Given a scale name, return its intervals. The name can be the type and\n * optionally the tonic (which is ignored)\n *\n * It retruns an empty array when no scale found\n *\n * @function\n * @param {string} name - the scale name (tonic and type, tonic is optional)\n * @return {Array<string>} the scale intervals if is a known scale or an empty\n * array if no scale found\n * @example\n * Scale.intervals(\"major\") // => [ \"1P\", \"2M\", \"3M\", \"4P\", \"5P\", \"6M\", \"7M\" ]\n */\nexport var intervals = function (name) {\n  var p = tokenize(name);\n  return props(p[1]).intervals;\n};\n\n/**\n * Get the notes (pitch classes) of a scale.\n *\n * Note that it always returns an array, and the values are only pitch classes.\n *\n * @function\n * @param {string} tonic\n * @param {string} nameOrTonic - the scale name or tonic (if 2nd param)\n * @param {string} [name] - the scale name without tonic\n * @return {Array} a pitch classes array\n *\n * @example\n * Scale.notes(\"C\", \"major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"C major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"C4\", \"major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"A4\", \"no-scale\") // => []\n * Scale.notes(\"blah\", \"major\") // => []\n */\nexport function notes(nameOrTonic, name) {\n  var p = tokenize(nameOrTonic);\n  name = name || p[1];\n  return intervals(name).map(transpose(p[0]));\n}\n\n/**\n * Check if the given name is a known scale from the scales dictionary\n *\n * @function\n * @param {string} name - the scale name\n * @return {Boolean}\n */\nexport function exists(name) {\n  var p = tokenize(name);\n  return scale(p[1]) !== undefined;\n}\n\n/**\n * Given a string with a scale name and (optionally) a tonic, split\n * that components.\n *\n * It retuns an array with the form [ name, tonic ] where tonic can be a\n * note name or null and name can be any arbitrary string\n * (this function doesn\"t check if that scale name exists)\n *\n * @function\n * @param {string} name - the scale name\n * @return {Array} an array [tonic, name]\n * @example\n * Scale.tokenize(\"C mixolydean\") // => [\"C\", \"mixolydean\"]\n * Scale.tokenize(\"anything is valid\") // => [\"\", \"anything is valid\"]\n * Scale.tokenize() // => [\"\", \"\"]\n */\nexport function tokenize(str) {\n  if (typeof str !== \"string\") { return [\"\", \"\"]; }\n  var i = str.indexOf(\" \");\n  var tonic = noteName(str.substring(0, i)) || noteName(str) || \"\";\n  var name = tonic !== \"\" ? str.substring(tonic.length + 1) : str;\n  return [tonic, name.length ? name : \"\"];\n}\n\n/**\n * Find mode names of a scale\n *\n * @function\n * @param {string} name - scale name\n * @example\n * Scale.modeNames(\"C pentatonic\") // => [\n *   [\"C\", \"major pentatonic\"],\n *   [\"D\", \"egyptian\"],\n *   [\"E\", \"malkos raga\"],\n *   [\"G\", \"ritusen\"],\n *   [\"A\", \"minor pentatonic\"]\n * ]\n */\nexport var modeNames = function (name) {\n  var ivls = intervals(name);\n  var tonics = notes(name);\n\n  return pcsetModes(ivls)\n    .map(function (chroma, i) {\n      var name = scale.names(chroma)[0];\n      if (name) { return [tonics[i] || ivls[i], name]; }\n    })\n    .filter(function (x) { return x; });\n};\n\n/**\n * Get all chords that fits a given scale\n *\n * @function\n * @param {string} name - the scale name\n * @return {Array<string>} - the chord names\n *\n * @example\n * Scale.chords(\"pentatonic\") // => [\"5\", \"64\", \"M\", \"M6\", \"Madd9\", \"Msus2\"]\n */\nexport var chords = function (name) {\n  var inScale = isSubsetOf(intervals(name));\n  return chord.names().filter(function (name) { return inScale(chord(name)); });\n};\n\n/**\n * Given an array of notes, return the scale: a pitch class set starting from\n * the first note of the array\n *\n * @function\n * @param {Array} notes\n * @return {Array}\n * @example\n * Scale.toScale(['C4', 'c3', 'C5', 'C4', 'c4']) // => [\"C\"]\n * Scale.toScale(['D4', 'c#5', 'A5', 'F#6']) // => [\"D\", \"F#\", \"A\", \"C#\"]\n */\nexport var toScale = function (notes) {\n  var pcset = compact(notes.map(pc));\n  if (!pcset.length) { return pcset; }\n  var tonic = pcset[0];\n  var scale = unique(pcset);\n  return rotate(scale.indexOf(tonic), scale);\n};\n\n/**\n * Get all scales names that are a superset of the given one\n * (has the same notes and at least one more)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of scale names\n * @example\n * Scale.supersets(\"major\") // => [\"bebop\", \"bebop dominant\", \"bebop major\", \"chromatic\", \"ichikosucho\"]\n */\nexport var supersets = function (name) {\n  if (!intervals(name).length) { return []; }\n  var isSuperset = isSupersetOf(intervals(name));\n  return scale.names().filter(function (name) { return isSuperset(scale(name)); });\n};\n\n/**\n * Find all scales names that are a subset of the given one\n * (has less notes but all from the given scale)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of scale names\n *\n * @example\n * Scale.subsets(\"major\") // => [\"ionian pentatonic\", \"major pentatonic\", \"ritusen\"]\n */\nexport var subsets = function (name) {\n  var isSubset = isSubsetOf(intervals(name));\n  return scale.names().filter(function (name) { return isSubset(scale(name)); });\n};\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-chord.svg)](https://www.npmjs.com/package/tonal-chord)\n * [![tonal](https://img.shields.io/badge/tonal-chord-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-chord` is a collection of functions to manipulate musical chords\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * // es6\n * import * as Chord from \"tonal-chord\"\n * // es5\n * const Chord = require(\"tonal-chord\")\n *\n * @example\n * Chord.notes(\"CMaj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n *\n * @module Chord\n */\nimport { tokenize as split } from \"tonal-note\";\nimport { transpose } from \"tonal-distance\";\nimport { chord } from \"tonal-dictionary\";\nimport { chroma, isSubsetOf, isSupersetOf } from \"tonal-pcset\";\n\n/**\n * Return the available chord names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the chord names\n *\n * @example\n * Chord.names() // => [\"maj7\", ...]\n */\nexport var names = chord.names;\n\nvar NO_CHORD = Object.freeze({\n  name: null,\n  names: [],\n  intervals: [],\n  chroma: null,\n  setnum: null\n});\n\nvar properties = function (name) {\n  var intervals = chord(name);\n  if (!intervals) { return NO_CHORD; }\n  var s = { intervals: intervals, name: name };\n  s.chroma = chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = chord.names(s.chroma);\n  return s;\n};\n\nvar memo = function (fn, cache) {\n  if ( cache === void 0 ) cache = {};\n\n  return function (str) { return cache[str] || (cache[str] = fn(str)); };\n};\n\n/**\n * Get chord properties. It returns an object with:\n *\n * - name: the chord name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the chord intervals\n * - chroma:  chord croma (see pcset)\n * - setnum: chord chroma number\n *\n * @function\n * @param {string} name - the chord name (without tonic)\n * @return {Object} an object with the properties or a object with all properties\n * set to null if not valid chord name\n */\nexport var props = memo(properties);\n\n/**\n * Get chord intervals. It always returns an array\n *\n * @function\n * @param {string} name - the chord name (optionally a tonic and type)\n * @return {Array<String>} a list of intervals or null if the type is not known\n */\nexport var intervals = function (name) { return props(tokenize(name)[1]).intervals; };\n\n/**\n * Get the chord notes of a chord. This function accepts either a chord name\n * (for example: \"Cmaj7\") or a list of notes.\n *\n * It always returns an array, even if the chord is not found.\n *\n * @function\n * @param {string} nameOrTonic - name of the chord or the tonic (if the second parameter is present)\n * @param {string} [name] - (Optional) name if the first parameter is the tonic\n * @return {Array} an array of notes or an empty array\n *\n * @example\n * Chord.notes(\"Cmaj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n * Chord.notes(\"C\", \"maj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n */\nexport function notes(nameOrTonic, name) {\n  if (name) { return props(name).intervals.map(transpose(nameOrTonic)); }\n  var ref = tokenize(nameOrTonic);\n  var tonic = ref[0];\n  var type = ref[1];\n  return props(type).intervals.map(transpose(tonic));\n}\n\n/**\n * Check if a given name correspond to a chord in the dictionary\n *\n * @function\n * @param {string} name\n * @return {Boolean}\n * @example\n * Chord.exists(\"CMaj7\") // => true\n * Chord.exists(\"Maj7\") // => true\n * Chord.exists(\"Ablah\") // => false\n */\nexport var exists = function (name) { return chord(tokenize(name)[1]) !== undefined; };\n\n/**\n * Get all chords names that are a superset of the given one\n * (has the same notes and at least one more)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of chord names\n */\nexport var supersets = function (name) {\n  if (!intervals(name).length) { return []; }\n  var isSuperset = isSupersetOf(intervals(name));\n  return chord.names().filter(function (name) { return isSuperset(chord(name)); });\n};\n\n/**\n * Find all chords names that are a subset of the given one\n * (has less notes but all from the given chord)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of chord names\n */\nexport var subsets = function (name) {\n  var isSubset = isSubsetOf(intervals(name));\n  return chord.names().filter(function (name) { return isSubset(chord(name)); });\n};\n\n// 6, 64, 7, 9, 11 and 13 are consider part of the chord\n// (see https://github.com/danigb/tonal/issues/55)\nvar NUM_TYPES = /^(6|64|7|9|11|13)$/;\n/**\n * Tokenize a chord name. It returns an array with the tonic and chord type\n * If not tonic is found, all the name is considered the chord name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @function\n * @param {string} name - the chord name\n * @return {Array} an array with [tonic, type]\n * @example\n * Chord.tokenize(\"Cmaj7\") // => [ \"C\", \"maj7\" ]\n * Chord.tokenize(\"C7\") // => [ \"C\", \"7\" ]\n * Chord.tokenize(\"mMaj7\") // => [ \"\", \"mMaj7\" ]\n * Chord.tokenize(\"Cnonsense\") // => [ \"C\", \"nonsense\" ]\n */\nexport function tokenize(name) {\n  var p = split(name);\n  if (p[0] === \"\") { return [\"\", name]; }\n  // aug is augmented (see https://github.com/danigb/tonal/issues/55)\n  if (p[0] === \"A\" && p[3] === \"ug\") { return [\"\", \"aug\"]; }\n\n  if (NUM_TYPES.test(p[2])) {\n    return [p[0] + p[1], p[2] + p[3]];\n  } else {\n    return [p[0] + p[1] + p[2], p[3]];\n  }\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-key.svg?style=flat-square)](https://www.npmjs.com/package/tonal-key)\n *\n * The `Tonal` module is a facade to the rest of the modules. They are namespaced,\n * so for example to use `pc` function from `tonal-note` you have to write:\n * `Tonal.Note.pc`\n *\n * It exports the following modules:\n * - Note\n * - Interval\n * - Distance\n * - Scale\n * - Chord\n * - PcSet\n *\n * Additionally this facade exports some functions without namespace (see \"Methods\" below)\n *\n * @example\n * // es6 modules\n * import * as Tonal from \"tonal\"\n * Tonal.Note.name(\"cx\") // => \"C##\"\n *\n * @example\n * import { Note } from \"tonal\"\n * Note.name(\"bb\") // => \"Bb\"\n *\n * @example\n * // es5 node modules\n * var Tonal = require(\"tonal\");\n * Tonal.Distance.transpose(Tonal.Note.pc(\"C#2\"), \"M3\") // => \"E#\"\n * Tonal.Chord.notes(\"Dmaj7\") // => [\"D\", \"F#\", \"A\", \"C#\"]\n *\n * @module Tonal\n */\nimport * as Array from \"tonal-array\";\nimport * as Note from \"tonal-note\";\nimport * as Interval from \"tonal-interval\";\nimport * as Distance from \"tonal-distance\";\nimport * as Dictionary from \"tonal-dictionary\";\nimport * as Scale from \"tonal-scale\";\nimport * as Chord from \"tonal-chord\";\nimport * as PcSet from \"tonal-pcset\";\n\nexport { Array, Note, Interval, Distance, Scale, Chord, PcSet, Dictionary };\n\n/**\n * Transpose a note by an interval\n * @function\n * @param {string} note\n * @param {string} interval\n * @return {string} the transported note\n * @see Distance.transpose\n */\nexport const transpose = Distance.transpose;\n\n/**\n * Get the interval from two notes\n * @function\n * @param {string} from\n * @param {string} to\n * @return {string} the interval in reverse shorthand notation\n * @see Distance.interval\n */\nexport const interval = Distance.interval;\n\n/**\n * Get note properties\n * @function\n * @param {string} note - the note name\n * @return {Object}\n * @see Note.props\n * @example\n * Tonal.note(\"A4\").chroma // => 9\n */\nexport const note = Note.props;\n\n/**\n * Get midi note number\n * @function\n * @param {string} note\n * @return {Number}\n * @see Note.midi\n * @example\n * Tonal.midi(\"A4\") // => 49\n */\nexport const midi = Note.midi;\n\n/**\n * Get note frequency using equal tempered tuning at 440\n * @function\n * @param {string} note\n * @return {Number}\n * @see Note.freq\n * @example\n * Tonal.freq(\"A4\") // => 440\n */\nexport const freq = Note.freq;\n\n/**\n * Get intervals from a chord type\n * @function\n * @param {string} type - the chord type (no tonic)\n * @return {Array} an array of intervals or undefined if the chord type is not known\n * @see Dictionary.chord\n * @example\n * Tonal.chord(\"m7b5\") // => [\"1P\", \"3m\", \"5d\", \"7m\"]\n */\nexport const chord = Dictionary.chord;\n\n/**\n * Get intervals from scale name\n * @function\n * @param {string} name - the scale name (without tonic)\n * @return {Array} an array of intervals or undefiend if the scale is not kown\n * @example\n * Tonal.scale(\"major\") // => [\"1P\", \"2M\", \"3M\"...]\n */\nexport const scale = Dictionary.scale;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scale_1 = require(\"./scale\");\nexports.scale = scale_1.getScale;\nexports.mode = scale_1.getScale;\nexports.scales = scale_1.scales;\nexports.modes = scale_1.scales;\nconst chord_1 = require(\"./chord\");\nexports.chord = chord_1.getChord;\nexports.chords = chord_1.chords;\nconst clip_1 = require(\"./clip\");\nexports.clip = clip_1.clip;\nconst progression_1 = require(\"./progression\");\nexports.progression = progression_1.get;\nconst arp_1 = require(\"./arp\");\nexports.arp = arp_1.arp;\nconst midi_1 = require(\"./midi\");\nexports.midi = midi_1.midi;\nconst session_1 = require(\"./session\");\nexports.session = session_1.Session;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst defaultSubdiv = '4n';\nconst defaultDur = '8n';\n/**\n * @param  {Tone.js Player Object}\n * @return {Function}\n * Take a Tone.js Player and return a function that can be used\n * as the callback in Tone.Sequence https://tonejs.github.io/docs/r12/Sequence\n */\nconst getPlayerSeqFn = (player) => {\n    return (time, el) => {\n        if (el === 'x') {\n            player.start(time);\n        }\n    };\n};\n/**\n * @param  {Object}\n * @return {Function}\n * Take an object literal which has a Tone.js instrument and return a function that can be used\n * as the callback in Tone.Sequence https://tonejs.github.io/docs/r12/Sequence\n */\nconst getInstrSeqFn = (params) => {\n    let counter = 0;\n    return (time, el) => {\n        if (el === 'x' && params.notes[counter]) {\n            params.instrument.triggerAttackRelease(params.notes[counter], params.dur || params.subdiv || defaultDur, time);\n            counter++;\n            if (counter === params.notes.length) {\n                counter = 0;\n            }\n        }\n    };\n};\n/**\n * @param  {Object}\n * @return {Function}\n * Take an object literal which has a Tone.js instrument and return a function that can be used\n * as the callback in Tone.Sequence https://tonejs.github.io/docs/r12/Sequence\n */\nconst getMonoInstrSeqFn = (params) => {\n    let counter = 0;\n    return (time, el) => {\n        if (el === 'x' && params.notes[counter]) {\n            // in monophonic instruments the triggerAttackRelease takes the note directly\n            // In Scribbletune each note is an array by default to support chords\n            // hence we target the 0th element of each note\n            params.instrument.triggerAttackRelease(params.notes[counter][0], params.dur || params.subdiv || defaultDur, time);\n            counter++;\n            if (counter === params.notes.length) {\n                counter = 0;\n            }\n        }\n    };\n};\n/**\n * @param  {Object}\n * @return {Function}\n * Take an object literal which has a Tone.js sampler and return a function that can be used\n * as the callback in Tone.Sequence https://tonejs.github.io/docs/r12/Sequence\n */\nconst getSamplerSeqFn = (params) => {\n    let counter = 0;\n    return (time, el) => {\n        if (el === 'x' && params.notes[counter]) {\n            params.sampler.triggerAttackRelease(params.notes[counter], params.dur || params.subdiv || defaultDur, time);\n            counter++;\n            if (counter === params.notes.length) {\n                counter = 0;\n            }\n        }\n    };\n};\n/**\n * @param  {Object}\n * @return {Tone.js Sequence Object}\n * Take a object literal that may have a Tone.js player OR instrument\n * or simply a sample or synth with a pattern and return a Tone.js sequence\n */\nmodule.exports = (params) => {\n    if (!params.pattern) {\n        throw new Error('No pattern provided!');\n    }\n    if (!params.player &&\n        !params.instrument &&\n        !params.sample &&\n        !params.synth &&\n        !params.sampler &&\n        !params.samples) {\n        throw new Error('No player or instrument provided!');\n    }\n    /*\n      1. The params object can be used to pass a sample (sound source) OR a synth(Synth/FMSynth/AMSynth etc) or samples.\n      Scribbletune will then create a Tone.js Player or Tone.js Instrument or Tone.js Sampler respectively\n      2. It can also be used to pass a Tone.js Player object or instrument that was created elsewhere\n      (mostly by Scribbletune itself in the channel creation method)\n      Either ways, a pattern is required and it will be used to create a playable Tone.js Sequence\n       */\n    let effects = [];\n    if (params.effects) {\n        effects = params.effects.map((eff) => new Tone[eff]());\n    }\n    effects.push(new Tone.PanVol(params.pan || 0, params.volume || -12));\n    if (params.sample) {\n        // This implies, the clip is probably being hand created by the user with a audio sample\n        params.player = new Tone.Player(params.sample);\n    }\n    if (params.samples) {\n        params.sampler = new Tone.Sampler(params.samples);\n    }\n    if (params.synth) {\n        // This implies, the synth is probably being hand created by the user with an available Tone synth\n        params.instrument = new Tone[params.synth]();\n    }\n    if (params.player) {\n        params.player.chain(...effects, Tone.Master);\n        // This implies, a player object was already created (either by user or by Scribbletune during channel creation)\n        return new Tone.Sequence(getPlayerSeqFn(params.player), utils_1.expandStr(params.pattern), params.subdiv || defaultSubdiv);\n    }\n    if (params.sampler) {\n        params.sampler.chain(...effects, Tone.Master);\n        // This implies, a sampler object was already created (either by user or by Scribbletune during channel creation)\n        return new Tone.Sequence(getSamplerSeqFn(params), utils_1.expandStr(params.pattern), params.subdiv || defaultSubdiv);\n    }\n    if (params.instrument) {\n        params.instrument.chain(...effects, Tone.Master);\n        // This implies, the instrument was already created (either by user or by Scribbletune during channel creation)\n        // Unlike player, the instrument needs the entire params object to construct a sequence\n        return new Tone.Sequence(params.instrument.voices\n            ? getInstrSeqFn(params)\n            : getMonoInstrSeqFn(params), utils_1.expandStr(params.pattern), params.subdiv || defaultSubdiv);\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scale_1 = require(\"./scale\");\n/**\n * Get the chords that go with a given scale/mode\n * This is useful only in case you want to check what chords work with a scale/mode\n * so that you can come up with chord progressions\n * @param  {String} mode e.g. major\n * @return {Array} e.g.['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°']\n */\nexports.get = (mode) => {\n    const theRomans = {\n        ionian: ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°'],\n        dorian: ['i', 'ii', 'III', 'IV', 'v', 'vi°', 'VII'],\n        phrygian: ['i', 'II', 'III', 'iv', 'v°', 'VI', 'vii'],\n        lydian: ['I', 'II', 'iii', 'iv°', 'V', 'vi', 'vii'],\n        mixolydian: ['I', 'ii', 'iii°', 'IV', 'v', 'vi', 'VII'],\n        aeolian: ['i', 'ii°', 'III', 'iv', 'v', 'VI', 'VII'],\n        locrian: ['i°', 'II', 'iii', 'iv', 'V', 'VI', 'vii'],\n        'melodic minor': ['i', 'ii', 'III+', 'IV', 'V', 'vi°', 'vii°'],\n        'harmonic minor': ['i', 'ii°', 'III+', 'iv', 'V', 'VI', 'vii°'],\n    };\n    theRomans.major = theRomans.ionian;\n    theRomans.minor = theRomans.aeolian;\n    return theRomans[mode] || [];\n};\nconst idxByDegree = {\n    i: 0,\n    ii: 1,\n    iii: 2,\n    iv: 3,\n    v: 4,\n    vi: 5,\n    vii: 6,\n};\n/**\n * Get a chord name from degree\n * @param  {String} roman e.g. ii OR ii° OR V7\n * @return {String} e.g. m OR m7b5 OR Maj7\n */\nconst getChordName = (roman) => {\n    // remove any non character\n    const str = roman.replace(/\\W/g, '');\n    let prefix = 'M';\n    // check if it s lowercase\n    if (str.toLowerCase() === str) {\n        prefix = 'm';\n    }\n    if (roman.includes('°')) {\n        return prefix + '7b5';\n    }\n    if (roman.includes('+')) {\n        return prefix + '#5';\n    }\n    if (roman.includes('7')) {\n        return prefix === 'M' ? 'Maj7' : 'm7';\n    }\n    return prefix;\n};\n/**\n * Take the specified scale and degrees and return the chord names for them\n * These can be used as the value for the `notes` param of the `clip` method\n * @param {String} noteOctaveScale e.g. 'C4 major'\n * @param  {String} chordDegress e.g. 'I IV V IV'\n * @return {String} e.g. 'CM FM GM FM'\n */\nexports.getChords = (noteOctaveScale, chordDegress) => {\n    // Set the octave if missing\n    // For example if the method was called with `C major` instead of `C4 major`, then add the 4\n    const noteOctaveScaleArr = noteOctaveScale.split(' ');\n    if (!noteOctaveScaleArr[0].match(/\\d/)) {\n        noteOctaveScaleArr[0] += '4';\n        noteOctaveScale = noteOctaveScaleArr.join(' ');\n    }\n    // Get the scale from the given note and scale/mode combination\n    const mode = scale_1.getScale(noteOctaveScale);\n    const chordDegreesArr = chordDegress.replace(/\\s*,+\\s*/g, ' ').split(' ');\n    // Now we have something like ['i', 'ii', 'IV']\n    // Convert it to a chord family such as ['Cm', 'Dm', 'FM']\n    const chordFamily = chordDegreesArr.map((roman, idx) => {\n        const chordName = getChordName(roman); // e.g. m\n        // get the index to be used by removing any digit or non alphabet character\n        const scaleId = idxByDegree[roman.replace(/\\W|\\d/g, '').toLowerCase()]; // e.g. 0\n        // get the note itself\n        const note = mode[scaleId]; // e.g. C\n        // get the octave of the note;\n        const oct = note.replace(/\\D+/, ''); // e.g. 4\n        // now get the chord\n        return note.replace(/\\d/, '') + chordName + '-' + oct;\n    });\n    return chordFamily.toString().replace(/,/g, ' ');\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chord_1 = require(\"./chord\");\n/**\n * Take an array and fill it with it s own elements in the next octave till it s of the specified `len`\n * @param  {Array} arr e.g. ['a4', 'b4']\n * @param  {Number} e.g. len 4\n * @return {Array} e.g. ['a4', 'b4', 'a5', 'b5']\n */\nconst fillArr = (arr, len) => {\n    const bumpOctave = (el) => {\n        const note = el.replace(/\\d/, '');\n        const oct = el.replace(/\\D/g, '');\n        return note + (+oct + 1);\n    };\n    // Create a couple of chord arrays with bumped octaves\n    // so that something like [c3, e3, g4] turns into [c4, e4, g5] and [c5, e5, g6]\n    const arr1 = arr.map(bumpOctave);\n    const arr2 = arr1.map(bumpOctave);\n    const finalArr = [...arr, ...arr1, ...arr2];\n    // Slice and return only as much as required\n    return finalArr.slice(0, len);\n};\n/**\n *\n * @param chordsOrParams a string that denotes comma seprated chords to be used or an object with additional properties\n * By default, if this is a string, the the count of notes generated is 8 and the order is ascending.\n * For instance arp('CM FM') will result in an array of notes [C4, E4, G4, F4, A4, C4, C5, E5]\n */\nexports.arp = (chordsOrParams) => {\n    let finalArr = [];\n    const params = {\n        count: 8,\n        order: '01234567',\n        chords: '',\n    };\n    if (typeof chordsOrParams === 'string') {\n        params.chords = chordsOrParams;\n    }\n    else {\n        Object.assign(params, chordsOrParams);\n    }\n    if (params.count > 8 || params.count < 2) {\n        throw new TypeError('Invalid value for count');\n    }\n    if (params.order.match(/\\D/g) ||\n        params.order.includes('8') ||\n        params.order.includes('9')) {\n        throw new TypeError('Invalid value for order');\n    }\n    const chordsArr = params.chords.split(' ');\n    for (const chord of chordsArr) {\n        const filledArr = fillArr(chord_1.getChord(chord), params.count);\n        // reorder the filledArr as per params.order\n        const reorderedArr = params.order\n            .split('')\n            .map((idx) => filledArr[idx]);\n        finalArr = [...finalArr, ...reorderedArr];\n    }\n    return finalArr;\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\"));\nconst jsmidgen = __importStar(require(\"jsmidgen\"));\n/**\n * Take an array of note objects to generate a MIDI file in the same location as this method is called\n * @param  {<Array>NoteObject} notes    Notes are in the format: {note: ['c3'], level: 127, length: 64}\n * @param  {String | null} fileName If a filename is not provided, then `music.mid` is used by default\n * If `null` is passed for `fileName`, bytes are returned instead of creating a file\n */\nexports.midi = (notes, fileName) => {\n    const file = createFileFromNotes(notes);\n    const bytes = file.toBytes();\n    if (fileName === null) {\n        return bytes;\n    }\n    if (fileName && !fileName.endsWith('.mid')) {\n        fileName = fileName + '.mid';\n    }\n    fs_1.default.writeFileSync(fileName || 'music.mid', bytes, 'binary');\n    console.log(`MIDI file generated: ${fileName}.`);\n};\nfunction createFileFromNotes(notes) {\n    const file = new jsmidgen.File();\n    const track = new jsmidgen.Track();\n    file.addTrack(track);\n    for (const noteObj of notes) {\n        const level = noteObj.level || 127;\n        // While writing chords (multiple notes per tick)\n        // only the first noteOn (or noteOff) needs the complete arity of the function call\n        // subsequent calls need only the first 2 args (channel and note)\n        if (noteObj.note) {\n            if (typeof noteObj.note === 'string') {\n                track.noteOn(0, noteObj.note, noteObj.length, level); // channel, pitch(note), length, velocity\n                track.noteOff(0, noteObj.note, noteObj.length, level);\n            }\n            else {\n                track.addChord(0, noteObj.note, noteObj.length, level);\n            }\n        }\n        else {\n            track.noteOff(0, '', noteObj.length);\n        }\n    }\n    return file;\n}\n","var Midi = {};\n\n(function(exported) {\n\n\tvar DEFAULT_VOLUME   = exported.DEFAULT_VOLUME   = 90;\n\tvar DEFAULT_DURATION = exported.DEFAULT_DURATION = 128;\n\tvar DEFAULT_CHANNEL  = exported.DEFAULT_CHANNEL  = 0;\n\n\t/* ******************************************************************\n\t * Utility functions\n\t ****************************************************************** */\n\n\tvar Util = {\n\n\t\tmidi_letter_pitches: { a:21, b:23, c:12, d:14, e:16, f:17, g:19 },\n\n\t\t/**\n\t\t * Convert a symbolic note name (e.g. \"c4\") to a numeric MIDI pitch (e.g.\n\t\t * 60, middle C).\n\t\t *\n\t\t * @param {string} n - The symbolic note name to parse.\n\t\t * @returns {number} The MIDI pitch that corresponds to the symbolic note\n\t\t * name.\n\t\t */\n\t\tmidiPitchFromNote: function(n) {\n\t\t\tvar matches = /([a-g])(#+|b+)?([0-9]+)$/i.exec(n);\n\t\t\tvar note = matches[1].toLowerCase(), accidental = matches[2] || '', octave = parseInt(matches[3], 10);\n\t\t\treturn (12 * octave) + Util.midi_letter_pitches[note] + (accidental.substr(0,1)=='#'?1:-1) * accidental.length;\n\t\t},\n\n\t\t/**\n\t\t * Ensure that the given argument is converted to a MIDI pitch. Note that\n\t\t * it may already be one (including a purely numeric string).\n\t\t *\n\t\t * @param {string|number} p - The pitch to convert.\n\t\t * @returns {number} The resulting numeric MIDI pitch.\n\t\t */\n\t\tensureMidiPitch: function(p) {\n\t\t\tif (typeof p == 'number' || !/[^0-9]/.test(p)) {\n\t\t\t\t// numeric pitch\n\t\t\t\treturn parseInt(p, 10);\n\t\t\t} else {\n\t\t\t\t// assume it's a note name\n\t\t\t\treturn Util.midiPitchFromNote(p);\n\t\t\t}\n\t\t},\n\n\t\tmidi_pitches_letter: { '12':'c', '13':'c#', '14':'d', '15':'d#', '16':'e', '17':'f', '18':'f#', '19':'g', '20':'g#', '21':'a', '22':'a#', '23':'b' },\n\t\tmidi_flattened_notes: { 'a#':'bb', 'c#':'db', 'd#':'eb', 'f#':'gb', 'g#':'ab' },\n\n\t\t/**\n\t\t * Convert a numeric MIDI pitch value (e.g. 60) to a symbolic note name\n\t\t * (e.g. \"c4\").\n\t\t *\n\t\t * @param {number} n - The numeric MIDI pitch value to convert.\n\t\t * @param {boolean} [returnFlattened=false] - Whether to prefer flattened\n\t\t * notes to sharpened ones. Optional, default false.\n\t\t * @returns {string} The resulting symbolic note name.\n\t\t */\n\t\tnoteFromMidiPitch: function(n, returnFlattened) {\n\t\t\tvar octave = 0, noteNum = n, noteName, returnFlattened = returnFlattened || false;\n\t\t\tif (n > 23) {\n\t\t\t\t// noteNum is on octave 1 or more\n\t\t\t\toctave = Math.floor(n/12) - 1;\n\t\t\t\t// subtract number of octaves from noteNum\n\t\t\t\tnoteNum = n - octave * 12;\n\t\t\t}\n\n\t\t\t// get note name (c#, d, f# etc)\n\t\t\tnoteName = Util.midi_pitches_letter[noteNum];\n\t\t\t// Use flattened notes if requested (e.g. f# should be output as gb)\n\t\t\tif (returnFlattened && noteName.indexOf('#') > 0) {\n\t\t\t\tnoteName = Util.midi_flattened_notes[noteName];\n\t\t\t}\n\t\t\treturn noteName + octave;\n\t\t},\n\n\t\t/**\n\t\t * Convert beats per minute (BPM) to microseconds per quarter note (MPQN).\n\t\t *\n\t\t * @param {number} bpm - A number in beats per minute.\n\t\t * @returns {number} The number of microseconds per quarter note.\n\t\t */\n\t\tmpqnFromBpm: function(bpm) {\n\t\t\tvar mpqn = Math.floor(60000000 / bpm);\n\t\t\tvar ret=[];\n\t\t\tdo {\n\t\t\t\tret.unshift(mpqn & 0xFF);\n\t\t\t\tmpqn >>= 8;\n\t\t\t} while (mpqn);\n\t\t\twhile (ret.length < 3) {\n\t\t\t\tret.push(0);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Convert microseconds per quarter note (MPQN) to beats per minute (BPM).\n\t\t *\n\t\t * @param {number} mpqn - The number of microseconds per quarter note.\n\t\t * @returns {number} A number in beats per minute.\n\t\t */\n\t\tbpmFromMpqn: function(mpqn) {\n\t\t\tvar m = mpqn;\n\t\t\tif (typeof mpqn[0] != 'undefined') {\n\t\t\t\tm = 0;\n\t\t\t\tfor (var i=0, l=mpqn.length-1; l >= 0; ++i, --l) {\n\t\t\t\t\tm |= mpqn[i] << l;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Math.floor(60000000 / mpqn);\n\t\t},\n\n\t\t/**\n\t\t * Converts an array of bytes to a string of hexadecimal characters. Prepares\n\t\t * it to be converted into a base64 string.\n\t\t *\n\t\t * @param {Array} byteArray - Array of bytes to be converted.\n\t\t * @returns {string} Hexadecimal string, e.g. \"097B8A\".\n\t\t */\n\t\tcodes2Str: function(byteArray) {\n\t\t\treturn String.fromCharCode.apply(null, byteArray);\n\t\t},\n\n\t\t/**\n\t\t * Converts a string of hexadecimal values to an array of bytes. It can also\n\t\t * add remaining \"0\" nibbles in order to have enough bytes in the array as the\n\t\t * `finalBytes` parameter.\n\t\t *\n\t\t * @param {string} str - string of hexadecimal values e.g. \"097B8A\"\n\t\t * @param {number} [finalBytes] - Optional. The desired number of bytes\n\t\t * (not nibbles) that the returned array should contain.\n\t\t * @returns {Array} An array of nibbles.\n\t\t */\n\t\tstr2Bytes: function (str, finalBytes) {\n\t\t\tif (finalBytes) {\n\t\t\t\twhile ((str.length / 2) < finalBytes) { str = \"0\" + str; }\n\t\t\t}\n\n\t\t\tvar bytes = [];\n\t\t\tfor (var i=str.length-1; i>=0; i = i-2) {\n\t\t\t\tvar chars = i === 0 ? str[i] : str[i-1] + str[i];\n\t\t\t\tbytes.unshift(parseInt(chars, 16));\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t},\n\n\t\t/**\n\t\t * Translates number of ticks to MIDI timestamp format, returning an array\n\t\t * of bytes with the time values. MIDI has a very particular way to express\n\t\t * time; take a good look at the spec before ever touching this function.\n\t\t *\n\t\t * @param {number} ticks - Number of ticks to be translated.\n\t\t * @returns {number} Array of bytes that form the MIDI time value.\n\t\t */\n\t\ttranslateTickTime: function(ticks) {\n\t\t\tvar buffer = ticks & 0x7F;\n\n\t\t\twhile (ticks = ticks >> 7) {\n\t\t\t\tbuffer <<= 8;\n\t\t\t\tbuffer |= ((ticks & 0x7F) | 0x80);\n\t\t\t}\n\n\t\t\tvar bList = [];\n\t\t\twhile (true) {\n\t\t\t\tbList.push(buffer & 0xff);\n\n\t\t\t\tif (buffer & 0x80) { buffer >>= 8; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t\treturn bList;\n\t\t},\n\n\t};\n\n\t/* ******************************************************************\n\t * Event class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a MIDI event.\n\t *\n\t * Parameters include:\n\t *  - time [optional number] - Ticks since previous event.\n\t *  - type [required number] - Type of event.\n\t *  - channel [required number] - Channel for the event.\n\t *  - param1 [required number] - First event parameter.\n\t *  - param2 [optional number] - Second event parameter.\n\t */\n\tvar MidiEvent = function(params) {\n\t\tif (!this) return new MidiEvent(params);\n\t\tif (params &&\n\t\t\t\t(params.type    !== null || params.type    !== undefined) &&\n\t\t\t\t(params.channel !== null || params.channel !== undefined) &&\n\t\t\t\t(params.param1  !== null || params.param1  !== undefined)) {\n\t\t\tthis.setTime(params.time);\n\t\t\tthis.setType(params.type);\n\t\t\tthis.setChannel(params.channel);\n\t\t\tthis.setParam1(params.param1);\n\t\t\tthis.setParam2(params.param2);\n\t\t}\n\t};\n\n\t// event codes\n\tMidiEvent.NOTE_OFF           = 0x80;\n\tMidiEvent.NOTE_ON            = 0x90;\n\tMidiEvent.AFTER_TOUCH        = 0xA0;\n\tMidiEvent.CONTROLLER         = 0xB0;\n\tMidiEvent.PROGRAM_CHANGE     = 0xC0;\n\tMidiEvent.CHANNEL_AFTERTOUCH = 0xD0;\n\tMidiEvent.PITCH_BEND         = 0xE0;\n\n\n\t/**\n\t * Set the time for the event in ticks since the previous event.\n\t *\n\t * @param {number} ticks - The number of ticks since the previous event. May\n\t * be zero.\n\t */\n\tMidiEvent.prototype.setTime = function(ticks) {\n\t\tthis.time = Util.translateTickTime(ticks || 0);\n\t};\n\n\t/**\n\t * Set the type of the event. Must be one of the event codes on MidiEvent.\n\t *\n\t * @param {number} type - Event type.\n\t */\n\tMidiEvent.prototype.setType = function(type) {\n\t\tif (type < MidiEvent.NOTE_OFF || type > MidiEvent.PITCH_BEND) {\n\t\t\tthrow new Error(\"Trying to set an unknown event: \" + type);\n\t\t}\n\n\t\tthis.type = type;\n\t};\n\n\t/**\n\t * Set the channel for the event. Must be between 0 and 15, inclusive.\n\t *\n\t * @param {number} channel - The event channel.\n\t */\n\tMidiEvent.prototype.setChannel = function(channel) {\n\t\tif (channel < 0 || channel > 15) {\n\t\t\tthrow new Error(\"Channel is out of bounds.\");\n\t\t}\n\n\t\tthis.channel = channel;\n\t};\n\n\t/**\n\t * Set the first parameter for the event. Must be between 0 and 255,\n\t * inclusive.\n\t *\n\t * @param {number} p - The first event parameter value.\n\t */\n\tMidiEvent.prototype.setParam1 = function(p) {\n\t\tthis.param1 = p;\n\t};\n\n\t/**\n\t * Set the second parameter for the event. Must be between 0 and 255,\n\t * inclusive.\n\t *\n\t * @param {number} p - The second event parameter value.\n\t */\n\tMidiEvent.prototype.setParam2 = function(p) {\n\t\tthis.param2 = p;\n\t};\n\n\t/**\n\t * Serialize the event to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tMidiEvent.prototype.toBytes = function() {\n\t\tvar byteArray = [];\n\n\t\tvar typeChannelByte = this.type | (this.channel & 0xF);\n\n\t\tbyteArray.push.apply(byteArray, this.time);\n\t\tbyteArray.push(typeChannelByte);\n\t\tbyteArray.push(this.param1);\n\n\t\t// Some events don't have a second parameter\n\t\tif (this.param2 !== undefined && this.param2 !== null) {\n\t\t\tbyteArray.push(this.param2);\n\t\t}\n\t\treturn byteArray;\n\t};\n\n\t/* ******************************************************************\n\t * MetaEvent class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a meta event.\n\t *\n\t * Parameters include:\n\t *  - time [optional number] - Ticks since previous event.\n\t *  - type [required number] - Type of event.\n\t *  - data [optional array|string] - Event data.\n\t */\n\tvar MetaEvent = function(params) {\n\t\tif (!this) return new MetaEvent(params);\n\t\tvar p = params || {};\n\t\tthis.setTime(params.time);\n\t\tthis.setType(params.type);\n\t\tthis.setData(params.data);\n\t};\n\n\tMetaEvent.SEQUENCE   = 0x00;\n\tMetaEvent.TEXT       = 0x01;\n\tMetaEvent.COPYRIGHT  = 0x02;\n\tMetaEvent.TRACK_NAME = 0x03;\n\tMetaEvent.INSTRUMENT = 0x04;\n\tMetaEvent.LYRIC      = 0x05;\n\tMetaEvent.MARKER     = 0x06;\n\tMetaEvent.CUE_POINT  = 0x07;\n\tMetaEvent.CHANNEL_PREFIX = 0x20;\n\tMetaEvent.END_OF_TRACK   = 0x2f;\n\tMetaEvent.TEMPO      = 0x51;\n\tMetaEvent.SMPTE      = 0x54;\n\tMetaEvent.TIME_SIG   = 0x58;\n\tMetaEvent.KEY_SIG    = 0x59;\n\tMetaEvent.SEQ_EVENT  = 0x7f;\n\n\t/**\n\t * Set the time for the event in ticks since the previous event.\n\t *\n\t * @param {number} ticks - The number of ticks since the previous event. May\n\t * be zero.\n\t */\n\tMetaEvent.prototype.setTime = function(ticks) {\n\t\tthis.time = Util.translateTickTime(ticks || 0);\n\t};\n\n\t/**\n\t * Set the type of the event. Must be one of the event codes on MetaEvent.\n\t *\n\t * @param {number} t - Event type.\n\t */\n\tMetaEvent.prototype.setType = function(t) {\n\t\tthis.type = t;\n\t};\n\n\t/**\n\t * Set the data associated with the event. May be a string or array of byte\n\t * values.\n\t *\n\t * @param {string|Array} d - Event data.\n\t */\n\tMetaEvent.prototype.setData = function(d) {\n\t\tthis.data = d;\n\t};\n\n\t/**\n\t * Serialize the event to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tMetaEvent.prototype.toBytes = function() {\n\t\tif (!this.type) {\n\t\t\tthrow new Error(\"Type for meta-event not specified.\");\n\t\t}\n\n\t\tvar byteArray = [];\n\t\tbyteArray.push.apply(byteArray, this.time);\n\t\tbyteArray.push(0xFF, this.type);\n\n\t\t// If data is an array, we assume that it contains several bytes. We\n\t\t// apend them to byteArray.\n\t\tif (Array.isArray(this.data)) {\n\t\t\tbyteArray.push(this.data.length);\n\t\t\tbyteArray.push.apply(byteArray, this.data);\n\t\t} else if (typeof this.data == 'number') {\n\t\t\tbyteArray.push(1, this.data);\n\t\t} else if (this.data !== null && this.data !== undefined) {\n\t\t\t// assume string; may be a bad assumption\n\t\t\tbyteArray.push(this.data.length);\n\t\t\tvar dataBytes = this.data.split('').map(function(x){ return x.charCodeAt(0) });\n\t\t\tbyteArray.push.apply(byteArray, dataBytes);\n\t\t} else {\n\t\t\tbyteArray.push(0);\n\t\t}\n\n\t\treturn byteArray;\n\t};\n\n\t/* ******************************************************************\n\t * Track class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a MIDI track.\n\t *\n\t * Parameters include:\n\t *  - events [optional array] - Array of events for the track.\n\t */\n\tvar Track = function(config) {\n\t\tif (!this) return new Track(config);\n\t\tvar c = config || {};\n\t\tthis.events = c.events || [];\n\t};\n\n\tTrack.START_BYTES = [0x4d, 0x54, 0x72, 0x6b];\n\tTrack.END_BYTES   = [0x00, 0xFF, 0x2F, 0x00];\n\n\t/**\n\t * Add an event to the track.\n\t *\n\t * @param {MidiEvent|MetaEvent} event - The event to add.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addEvent = function(event) {\n\t\tthis.events.push(event);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The volume for the note, defaults to\n\t * DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNoteOn = Track.prototype.noteOn = function(channel, pitch, time, velocity) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.NOTE_ON,\n\t\t\tchannel: channel,\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-off event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The velocity the note was released,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNoteOff = Track.prototype.noteOff = function(channel, pitch, time, velocity) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.NOTE_OFF,\n\t\t\tchannel: channel,\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on and -off event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} dur - The duration of the note, in ticks.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The velocity the note was released,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNote = Track.prototype.note = function(channel, pitch, dur, time, velocity) {\n\t\tthis.noteOn(channel, pitch, time, velocity);\n\t\tif (dur) {\n\t\t\tthis.noteOff(channel, pitch, dur, velocity);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on and -off event to the track for each pitch in an array of pitches.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {array} chord - An array of pitches, either numeric or\n\t * symbolic.\n\t * @param {number} dur - The duration of the chord, in ticks.\n\t * @param {number} [velocity=90] - The velocity of the chord,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addChord = Track.prototype.chord = function(channel, chord, dur, velocity) {\n\t\tif (!Array.isArray(chord) && !chord.length) {\n\t\t\tthrow new Error('Chord must be an array of pitches');\n\t\t}\n\t\tchord.forEach(function(note) {\n\t\t\tthis.noteOn(channel, note, 0, velocity);\n\t\t}, this);\n\t\tchord.forEach(function(note, index) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis.noteOff(channel, note, dur);\n\t\t\t} else {\n\t\t\t\tthis.noteOff(channel, note);\n\t\t\t}\n\t\t}, this);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Set instrument for the track.\n\t *\n\t * @param {number} channel - The channel to set the instrument on.\n\t * @param {number} instrument - The instrument to set it to.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.setInstrument = Track.prototype.instrument = function(channel, instrument, time) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.PROGRAM_CHANGE,\n\t\t\tchannel: channel,\n\t\t\tparam1: instrument,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Set the tempo for the track.\n\t *\n\t * @param {number} bpm - The new number of beats per minute.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.setTempo = Track.prototype.tempo = function(bpm, time) {\n\t\tthis.events.push(new MetaEvent({\n\t\t\ttype: MetaEvent.TEMPO,\n\t\t\tdata: Util.mpqnFromBpm(bpm),\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Serialize the track to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tTrack.prototype.toBytes = function() {\n\t\tvar trackLength = 0;\n\t\tvar eventBytes = [];\n\t\tvar startBytes = Track.START_BYTES;\n\t\tvar endBytes   = Track.END_BYTES;\n\n\t\tvar addEventBytes = function(event) {\n\t\t\tvar bytes = event.toBytes();\n\t\t\ttrackLength += bytes.length;\n\t\t\teventBytes.push.apply(eventBytes, bytes);\n\t\t};\n\n\t\tthis.events.forEach(addEventBytes);\n\n\t\t// Add the end-of-track bytes to the sum of bytes for the track, since\n\t\t// they are counted (unlike the start-of-track ones).\n\t\ttrackLength += endBytes.length;\n\n\t\t// Makes sure that track length will fill up 4 bytes with 0s in case\n\t\t// the length is less than that (the usual case).\n\t\tvar lengthBytes = Util.str2Bytes(trackLength.toString(16), 4);\n\n\t\treturn startBytes.concat(lengthBytes, eventBytes, endBytes);\n\t};\n\n\t/* ******************************************************************\n\t * File class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a file object.\n\t *\n\t * Parameters include:\n\t *  - ticks [optional number] - Number of ticks per beat, defaults to 128.\n\t *    Must be 1-32767.\n\t *  - tracks [optional array] - Track data.\n\t */\n\tvar File = function(config){\n\t\tif (!this) return new File(config);\n\n\t\tvar c = config || {};\n\t\tif (c.ticks) {\n\t\t\tif (typeof c.ticks !== 'number') {\n\t\t\t\tthrow new Error('Ticks per beat must be a number!');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (c.ticks <= 0 || c.ticks >= (1 << 15) || c.ticks % 1 !== 0) {\n\t\t\t\tthrow new Error('Ticks per beat must be an integer between 1 and 32767!');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.ticks = c.ticks || 128;\n\t\tthis.tracks = c.tracks || [];\n\t};\n\n\tFile.HDR_CHUNKID     = \"MThd\";             // File magic cookie\n\tFile.HDR_CHUNK_SIZE  = \"\\x00\\x00\\x00\\x06\"; // Header length for SMF\n\tFile.HDR_TYPE0       = \"\\x00\\x00\";         // Midi Type 0 id\n\tFile.HDR_TYPE1       = \"\\x00\\x01\";         // Midi Type 1 id\n\n\t/**\n\t * Add a track to the file.\n\t *\n\t * @param {Track} track - The track to add.\n\t */\n\tFile.prototype.addTrack = function(track) {\n\t\tif (track) {\n\t\t\tthis.tracks.push(track);\n\t\t\treturn this;\n\t\t} else {\n\t\t\ttrack = new Track();\n\t\t\tthis.tracks.push(track);\n\t\t\treturn track;\n\t\t}\n\t};\n\n\t/**\n\t * Serialize the MIDI file to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tFile.prototype.toBytes = function() {\n\t\tvar trackCount = this.tracks.length.toString(16);\n\n\t\t// prepare the file header\n\t\tvar bytes = File.HDR_CHUNKID + File.HDR_CHUNK_SIZE;\n\n\t\t// set Midi type based on number of tracks\n\t\tif (parseInt(trackCount, 16) > 1) {\n\t\t\tbytes += File.HDR_TYPE1;\n\t\t} else {\n\t\t\tbytes += File.HDR_TYPE0;\n\t\t}\n\n\t\t// add the number of tracks (2 bytes)\n\t\tbytes += Util.codes2Str(Util.str2Bytes(trackCount, 2));\n\t\t// add the number of ticks per beat (currently hardcoded)\n\t\tbytes += String.fromCharCode((this.ticks/256),  this.ticks%256);;\n\n\t\t// iterate over the tracks, converting to bytes too\n\t\tthis.tracks.forEach(function(track) {\n\t\t\tbytes += Util.codes2Str(track.toBytes());\n\t\t});\n\n\t\treturn bytes;\n\t};\n\n\t/* ******************************************************************\n\t * Exports\n\t ****************************************************************** */\n\n\texported.Util = Util;\n\texported.File = File;\n\texported.Track = Track;\n\texported.Event = MidiEvent;\n\texported.MetaEvent = MetaEvent;\n\n})( Midi );\n\nif (typeof module != 'undefined' && module !== null) {\n\tmodule.exports = Midi;\n} else if (typeof exports != 'undefined' && exports !== null) {\n\texports = Midi;\n} else {\n\tthis.Midi = Midi;\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_1 = require(\"./channel\");\nclass Session {\n    constructor(arr) {\n        arr = arr || [];\n        this.sessionChannels = arr.map((ch, i) => {\n            ch.idx = ch.idx || i;\n            return new channel_1.Channel(ch);\n        });\n    }\n    createChannel(ch) {\n        ch.idx = ch.idx || this.sessionChannels.length;\n        this.sessionChannels.push(new channel_1.Channel(ch));\n    }\n    get channels() {\n        return this.sessionChannels;\n    }\n    // Start the clips at a specific index in all the channels\n    startRow(idx) {\n        this.sessionChannels.forEach((ch) => {\n            ch.startClip(idx);\n        });\n    }\n}\nexports.Session = Session;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst clip_1 = require(\"./clip\");\n/**\n * Get the next logical position to play in the session\n * Tone has a build-in method `Tone.Transport.nextSubdivision('4n')`\n * but I think it s better to round off as follows for live performance\n */\nconst getNextPos = () => {\n    const arr = Tone.Transport.position.split(':');\n    // If we are still around 0:0:0x, then set start position to 0\n    if (arr[0] === '0' && arr[1] === '0') {\n        return 0;\n    }\n    // Else set it to the next bar\n    return +arr[0] + 1 + ':0:0';\n};\n/**\n * Channel\n * A channel is made up of a Tone.js Player/Instrument, one or more\n * Tone.js sequences (known as clips in Scribbletune)\n * & optionally a set of effects (with or without presets)\n *\n * API:\n * clips -> Get all clips for this channel\n * addClip ->\n */\nclass Channel {\n    constructor(params) {\n        (this.idx = params.idx), (this.activePatternIdx = -1);\n        this.channelClips = [];\n        if (params.sample) {\n            this.player = new Tone.Player(params.sample);\n            this.player.toMaster();\n        }\n        if (params.synth) {\n            this.instrument = new Tone[params.synth]();\n            this.instrument.toMaster();\n        }\n        if (params.samples) {\n            this.sampler = new Tone.Sampler(params.samples);\n            this.sampler.toMaster();\n        }\n        // Filter out unrequired params and create clip params object\n        const { clips, samples, sample, synth, ...originalParamsFiltered } = params;\n        params.clips.forEach((c) => {\n            this.addClip({ ...c, ...originalParamsFiltered });\n        }, this);\n    }\n    get clips() {\n        return this.channelClips;\n    }\n    startClip(idx) {\n        // Stop any other currently running clip\n        if (this.activePatternIdx > -1 && this.activePatternIdx !== idx) {\n            this.stopClip(this.activePatternIdx);\n        }\n        if (this.channelClips[idx] && this.channelClips[idx].state !== 'started') {\n            this.activePatternIdx = idx;\n            this.channelClips[idx].start(getNextPos());\n        }\n    }\n    stopClip(idx) {\n        this.channelClips[idx].stop(getNextPos());\n    }\n    addClip(clipParams, idx) {\n        idx = idx || this.channelClips.length;\n        if (clipParams.pattern) {\n            this.channelClips[idx] = clip_1.clip(Object.assign({\n                player: this.player,\n                instrument: this.instrument,\n                sampler: this.sampler,\n            }, clipParams));\n        }\n        else {\n            // Allow creation of empty clips\n            this.channelClips[idx] = null;\n        }\n    }\n    get activeClipIdx() {\n        return this.activePatternIdx;\n    }\n}\nexports.Channel = Channel;\n"],"sourceRoot":""}